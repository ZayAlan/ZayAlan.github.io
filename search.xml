<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>string补充</title>
    <url>/2020/02/26/string%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>将单个char转换为string类型</p>
<ul>
<li>错误做法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char a = &apos;a&apos;;</span><br><span class="line">string t = to_string(a);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样得到的t为a的ASCII码值。</p>
<ul>
<li>正确做法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//使用 string 的构造函数</span><br><span class="line">char a = &apos;a&apos;;</span><br><span class="line">string t(1,a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明string 后将char push_back</span><br><span class="line">string s1;</span><br><span class="line">s1.push_back(a);</span><br><span class="line"></span><br><span class="line">//使用stringstream</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; aa;</span><br><span class="line">string str2 = ss.str();</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结7</title>
    <url>/2019/09/05/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%937/</url>
    <content><![CDATA[<h1 id="1133-Splitting-A-Linked-List-25-链表"><a href="#1133-Splitting-A-Linked-List-25-链表" class="headerlink" title="1133. Splitting A Linked List (25) [链表]"></a>1133. Splitting A Linked List (25) [链表]</h1><p>我一开始想复杂了，分了负的、k前、k、k后四个部分存储，后来发现只需要将原来的分多次循环然后选取需要的部分push进ans就行了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start,n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;start,&amp;n,&amp;k);</span><br><span class="line">    Node origin[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ad,da,ne;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ad,&amp;da,&amp;ne);</span><br><span class="line">        origin[ad] = &#123;ad,da,ne&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; v,ans;</span><br><span class="line">    <span class="keyword">for</span>(;start!=<span class="number">-1</span>;start=origin[start].next)</span><br><span class="line">    &#123;</span><br><span class="line">        v.push_back(origin[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:v) <span class="keyword">if</span>(it.data&lt;<span class="number">0</span>) ans.push_back(it);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:v) <span class="keyword">if</span>(it.data&gt;=<span class="number">0</span> &amp;&amp; it.data&lt;=k) ans.push_back(it);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:v) <span class="keyword">if</span>(it.data &gt; k) ans.push_back(it);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size()<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d %05d\n"</span>,ans[i].address,ans[i].data,ans[i+<span class="number">1</span>].address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%05d %d -1\n"</span>,ans[ans.size()<span class="number">-1</span>].address,ans[ans.size()<span class="number">-1</span>].data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1132-Cut-Integer-20-分"><a href="#1132-Cut-Integer-20-分" class="headerlink" title="1132 Cut Integer (20 分)"></a>1132 Cut Integer (20 分)</h1><p>用string的substr和c++11的stoll一下子就做出来了，注意除数不能为0的情况，不然会出现浮点错误。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s,a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        a=s.substr(<span class="number">0</span>,s.length()/<span class="number">2</span>);</span><br><span class="line">        b=s.substr(s.length()/<span class="number">2</span>,s.length()/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ss,aa,bb;</span><br><span class="line">        ss = stoll(s);</span><br><span class="line">        aa = stoll(a);</span><br><span class="line">        bb = stoll(b);</span><br><span class="line">        <span class="keyword">if</span>(aa == <span class="number">0</span> || bb==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ss%(aa*bb)==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1128-N-Queens-Puzzle-20-分"><a href="#1128-N-Queens-Puzzle-20-分" class="headerlink" title="1128 N Queens Puzzle (20 分)"></a>1128 N Queens Puzzle (20 分)</h1><p><strong>n皇后问题忘了在同一条对角线上的性质了：两个格子的x之差的绝对值等于它们的y之差的绝对值，则在同一条对角线上，即abs(v[j]-v[t])=abs(j-t)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">int</span> n;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n);</span><br><span class="line">       <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;v[j];</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;j;t++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(<span class="built_in">abs</span>(v[j]-v[t])==<span class="built_in">abs</span>(j-t) || v[j]==v[t])</span><br><span class="line">               &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1117-Eddington-Number-25-简单逻辑题"><a href="#1117-Eddington-Number-25-简单逻辑题" class="headerlink" title="1117. Eddington Number(25) [简单逻辑题]"></a>1117. Eddington Number(25) [简单逻辑题]</h1><pre><code>while(e &lt; n &amp;&amp; ans[e] &gt; e+1) e++;
</code></pre><p>没转过来？？？</p>
<h1 id="1116-Come-on-Let’s-C-20-简单逻辑题"><a href="#1116-Come-on-Let’s-C-20-简单逻辑题" class="headerlink" title="1116. Come on! Let’s C (20) [简单逻辑题]"></a>1116. Come on! Let’s C (20) [简单逻辑题]</h1><p>有一个结点没通过，是我的质数判断函数出错了？？？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断质数函数，注意必须i*i&lt;=a</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> checked[<span class="number">10010</span>],ranked[<span class="number">10010</span>];</span><br><span class="line">    fill(checked,checked+<span class="number">10010</span>,<span class="number">0</span>);</span><br><span class="line">    fill(ranked,ranked+<span class="number">10010</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">        ranked[id]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d: "</span>,id);</span><br><span class="line">        <span class="keyword">if</span>(checked[id]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ranked[id]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Are you kidding?\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ranked[id]==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Mystery Award\n"</span>);</span><br><span class="line">                checked[id]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isPrime(ranked[id]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Minion\n"</span>);</span><br><span class="line">                checked[id]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Chocolate\n"</span>);</span><br><span class="line">                checked[id]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Checked\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1109-Group-Photo-25-逻辑题"><a href="#1109-Group-Photo-25-逻辑题" class="headerlink" title="1109. Group Photo (25) [逻辑题]"></a>1109. Group Photo (25) [逻辑题]</h1><p>较难，理清逻辑然后进行位置的计算，微调后AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.height != b.height) <span class="keyword">return</span> a.height&gt;b.height;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.name&lt;b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">int</span> high;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;name&gt;&gt;high;</span><br><span class="line">        ans.push_back(&#123;name,high&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">    <span class="keyword">int</span> row = n/k;</span><br><span class="line">    <span class="keyword">int</span> last = n-k*row+row;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt = last;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt = row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; v(cnt+<span class="number">1</span>);</span><br><span class="line">        v[cnt/<span class="number">2</span>+<span class="number">1</span>] = ans[t];</span><br><span class="line">        <span class="keyword">int</span> left = cnt/<span class="number">2</span>+<span class="number">1</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=t+<span class="number">1</span>;j&lt;t+cnt;j=j+<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v[left--]=ans[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = cnt/<span class="number">2</span>+<span class="number">1</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=t+<span class="number">2</span>;j&lt;t+cnt;j=j+<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            v[right++]=ans[j];</span><br><span class="line">        &#125;</span><br><span class="line">        t=t+cnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;v.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s"</span>,v[j].name.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1104-Sum-of-Number-Segments-20-数学问题-（这题超屌！）"><a href="#1104-Sum-of-Number-Segments-20-数学问题-（这题超屌！）" class="headerlink" title="1104. Sum of Number Segments (20) [数学问题]（这题超屌！）"></a>1104. Sum of Number Segments (20) [数学问题]（这题超屌！）</h1><p>一开始按常规的二重循环做，后面两个点都超时了，然后看答案，发现是用概率论的思维来处理的！<br><strong>对于每一个元素i，其所在的片段可分为两部分，以1,2,3…i其中一个为开始，以i+1,i+2…n其中一个为结尾，于是i所在的片段个数即为<code>i*(n-i+1)</code></strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;temp);</span><br><span class="line">        sum+=temp*i*(n-i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1097-Deduplication-on-a-Linked-List-25-链表"><a href="#1097-Deduplication-on-a-Linked-List-25-链表" class="headerlink" title="1097. Deduplication on a Linked List (25) [链表]"></a>1097. Deduplication on a Linked List (25) [链表]</h1><p>和上一个链表题类似的处理方法，先将链表型转换为vector，转换过程中即可分类去重，放入不同的vector中，最后在输出的时候进行next的调整即可。<br>（一开始的next忘记输出%05d了，找了半天才发现错哪）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node v[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">int</span> start,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;start,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ad,ke,ne;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ad,&amp;ke,&amp;ne);</span><br><span class="line">        v[ad]=&#123;ad,ke,ne&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; removed;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; dupl;</span><br><span class="line">    <span class="keyword">for</span>(;start!=<span class="number">-1</span>;start=v[start].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="built_in">abs</span>(v[start].data);</span><br><span class="line">        <span class="keyword">if</span>(dupl.find(key)!=dupl.end())</span><br><span class="line">        &#123;</span><br><span class="line">            removed.push_back(v[start]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(v[start]);</span><br><span class="line">            dupl.insert(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>,ans[i].address,ans[i].data);</span><br><span class="line">        <span class="keyword">if</span>(i!=ans.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>,ans[i+<span class="number">1</span>].address);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;removed.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>,removed[i].address,removed[i].data);</span><br><span class="line">        <span class="keyword">if</span>(i!=removed.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>,removed[i+<span class="number">1</span>].address);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1096-Consecutive-Factors-20-逻辑题"><a href="#1096-Consecutive-Factors-20-逻辑题" class="headerlink" title="1096. Consecutive Factors (20) [逻辑题]"></a>1096. Consecutive Factors (20) [逻辑题]</h1><p>不会。。。没思路。<br>分析：1，如果只有⼀个因⼦，那么这个数只能为1或者质数。因此我们主要去计算两个及以上因数的情况。 2，在有两个及以上的数连乘中，因数的最⼤上限为sqrt(N)，即N的平⽅根。 3，因此思路就是，不断构造连乘，看连乘的积是否是N的因数，如果是，则看这部分连乘的数的个数是否⽐已记录的多。 4，⽤变量first记录连乘的第⼀个数字，这⾥我把它赋初值为0，如果在寻找N的因数过程中，first没有改变，那么就表明N是1或者是⼀个质数～</p>
<p>修改之后，发现最后一个点超时，于是提前计算好sqrt(n)，通过！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> first =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxseq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;<span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&lt;=maxn;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp*=j;</span><br><span class="line">            <span class="keyword">if</span>(n%temp != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = j-i;</span><br><span class="line">        <span class="keyword">if</span>(len&gt;maxseq)</span><br><span class="line">        &#123;</span><br><span class="line">            first = i;</span><br><span class="line">            maxseq = len;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(first==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,maxseq);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxseq;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"*%d"</span>,first+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1093-Count-PAT’s-25-逻辑题"><a href="#1093-Count-PAT’s-25-逻辑题" class="headerlink" title="1093. Count PAT’s (25) [逻辑题]"></a>1093. Count PAT’s (25) [逻辑题]</h1><p>超高兴！一开始用二重循环，后三个全部超时，然后转换思路，增加几个记录变量，把里层循环提出来，进行两次一重循环，然后通过数学计算的方法得到pcnt和tcnt的值，计算得到结果！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100010</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;str);</span><br><span class="line">    <span class="keyword">int</span> pcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> psum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tsum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'P'</span>) psum++;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'T'</span>) tsum++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(str);i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i]==<span class="string">'P'</span>) pcnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i]==<span class="string">'T'</span>) tcnt++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pcnt!=<span class="number">0</span> &amp;&amp; tsum-tcnt!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=pcnt*(tsum-tcnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = sum%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1074-Reversing-Linked-List-25-链表"><a href="#1074-Reversing-Linked-List-25-链表" class="headerlink" title="1074. Reversing Linked List (25) [链表]"></a>1074. Reversing Linked List (25) [链表]</h1><p>我发现链表的题都是大同小异！AC！（突然感觉自己狂了起来(●ˇ∀ˇ●)嘿嘿嘿）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start,n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;start,&amp;n,&amp;k);</span><br><span class="line">    Node origin[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ad,da,ne;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ad,&amp;da,&amp;ne);</span><br><span class="line">        origin[ad]=&#123;ad,da,ne&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(;start!=<span class="number">-1</span>;start=origin[start].next)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(origin[start]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> len = ans.size()/k;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;ans.size();j=j+k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j+k&lt;=ans.size()) reverse(ans.begin()+j,ans.begin()+j+k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d %d"</span>,ans[i].address,ans[i].data);</span><br><span class="line">        <span class="keyword">if</span>(i!=ans.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" %05d\n"</span>,ans[i+<span class="number">1</span>].address);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" -1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1069-The-Black-Hole-of-Numbers-20-数学问题"><a href="#1069-The-Black-Hole-of-Numbers-20-数学问题" class="headerlink" title="1069. The Black Hole of Numbers (20) [数学问题]"></a>1069. The Black Hole of Numbers (20) [数学问题]</h1><p>sscanf和sprintf的活用！！！我会了！！！AC！！！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> n[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> get;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;get);</span><br><span class="line">    <span class="built_in">sprintf</span>(n,<span class="string">"%04d"</span>,get);</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sub,besub;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="number">6174</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(n,n+<span class="number">4</span>);</span><br><span class="line">        <span class="built_in">sscanf</span>(n,<span class="string">"%d"</span>,&amp;besub);</span><br><span class="line">        sort(n,n+<span class="number">4</span>,greater&lt;<span class="keyword">char</span>&gt;());</span><br><span class="line">        <span class="built_in">sscanf</span>(n,<span class="string">"%d"</span>,&amp;sub);</span><br><span class="line">        temp = sub - besub;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04d - %04d = %04d\n"</span>,sub,besub,temp);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">sprintf</span>(n,<span class="string">"%04d"</span>,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1052-Linked-List-Sorting-25-链表"><a href="#1052-Linked-List-Sorting-25-链表" class="headerlink" title="1052. Linked List Sorting (25) [链表]"></a>1052. Linked List Sorting (25) [链表]</h1><p>做法和之前的大同小异，但是没想到一点的是，可能给出的结点都不在结果里的情况，输出0 -1！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.data&lt;b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;start);</span><br><span class="line">    Node v[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ad,ke,ne;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;ad,&amp;ke,&amp;ne);</span><br><span class="line">        v[ad]=&#123;ad,ke,ne&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(;start!=<span class="number">-1</span>;start=v[start].next) ans.push_back(v[start]);</span><br><span class="line">    <span class="keyword">if</span>(ans.empty()) <span class="built_in">printf</span>(<span class="string">"0 -1"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %05d\n"</span>,ans.size(),ans[<span class="number">0</span>].address);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%05d %d "</span>,ans[i].address,ans[i].data);</span><br><span class="line">            <span class="keyword">if</span>(i!=ans.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%05d\n"</span>,ans[i+<span class="number">1</span>].address);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1049-Counting-Ones-30-数学问题"><a href="#1049-Counting-Ones-30-数学问题" class="headerlink" title="1049. Counting Ones (30) [数学问题]"></a>1049. Counting Ones (30) [数学问题]</h1><p>分析：这是⼀道数学问题。从第⼀位（个位）到最⾼位，设now为当前位的数字，lef为now左边的所有数字构成的数字，right是now右边的所有数字构成的数字。只需要⼀次次累加对于当前位now来说可能出现1的个数，然后把它们累加即可。a表示当前的个位为1，⼗位为10，百位为100类推。<br>对于now，有三种情况：<br>1.now == 0 : 那么 ans += lef <em> a; //因为now==0说明now位只有在lef从0~lef-1的时候会产⽣1，所以会产⽣lef次，但是⼜因为右边会重复从0~999…出现a次<br>2.now == 1 : ans += lef </em> a + right + 1;//now = 1的时候就要⽐上⼀步多加⼀个当now为1的时候右边出现0~right个数导致的now为1的次数<br>3.now &gt;= 2 : ans += (lef + 1) * a;//now⼤于等于2就左边0~lef的时候会在now位置产⽣1，所以会产⽣lef次，但是⼜因为右边会重复从0~999…出现a次<br>不懂。。。</p>
<h1 id="1032-Sharing-25-链表"><a href="#1032-Sharing-25-链表" class="headerlink" title="1032. Sharing (25) [链表]"></a>1032. Sharing (25) [链表]</h1><p>注意，比较时需要地址和data都相同时才算公用的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> address;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.data&lt;b.data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start1,start2,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;start1,&amp;start2,&amp;n);</span><br><span class="line">    Node v[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ad,ne;</span><br><span class="line">        <span class="keyword">char</span> ke;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %c %d"</span>,&amp;ad,&amp;ke,&amp;ne);</span><br><span class="line">        v[ad]=&#123;ad,ke,ne&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans1,ans2;</span><br><span class="line">    <span class="keyword">for</span>(;start1!=<span class="number">-1</span>;start1=v[start1].next) ans1.push_back(v[start1]);</span><br><span class="line">    <span class="keyword">for</span>(;start2!=<span class="number">-1</span>;start2=v[start2].next) ans2.push_back(v[start2]);</span><br><span class="line">    reverse(ans1.begin(),ans1.end());</span><br><span class="line">    reverse(ans2.begin(),ans2.end());</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans1.size() &amp;&amp; i&lt;ans2.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[i].data==ans2[i].data &amp;&amp; ans1[i].address == ans1[i].address)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%05d"</span>,ans1[pos].address);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1019-General-Palindromic-Number-20-分"><a href="#1019-General-Palindromic-Number-20-分" class="headerlink" title="1019 General Palindromic Number (20 分)"></a>1019 General Palindromic Number (20 分)</h1><p>之前搞错输出顺序了（尴尬地笑了）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;d);</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>,a[<span class="number">10000</span>];</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        a[len++] = n%d;</span><br><span class="line">        n/=d;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=a[len-i<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=len<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>链表</tag>
        <tag>数学问题</tag>
        <tag>逻辑题</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结6</title>
    <url>/2019/09/03/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%936/</url>
    <content><![CDATA[<h1 id="1125-Chain-the-Ropes-25-排序，贪⼼"><a href="#1125-Chain-the-Ropes-25-排序，贪⼼" class="headerlink" title="1125. Chain the Ropes (25) [排序，贪⼼]"></a>1125. Chain the Ropes (25) [排序，贪⼼]</h1><p>匪夷所思地AC了。。。我的思路就是从小到大排序，然后取最小的两个相加除以2，注意小数部分要在最后结果处才去掉。。。纯属凑巧。。。<br>真正解释：越是早加⼊绳⼦⻓度中的段，越要对折的次数多，所以既然希望绳⼦⻓度是最⻓的，就必须让⻓的段对折次数尽可能的短。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rope;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        rope.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(rope.begin(),rope.end());</span><br><span class="line">    <span class="keyword">double</span> temp = rope[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rope.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=<span class="number">1.0</span>*(temp+rope[i])/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = temp;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1113-Integer-Set-Partition-25-排序"><a href="#1113-Integer-Set-Partition-25-排序" class="headerlink" title="1113. Integer Set Partition (25) [排序]"></a>1113. Integer Set Partition (25) [排序]</h1><p>AC！难点在忘记用longlong型吧？<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end());</span><br><span class="line">    <span class="keyword">int</span> minimize;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maximize=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> first=<span class="number">0</span>,second=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        minimize=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            first+=ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            second+=ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maximize = second-first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        minimize = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n/<span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            first+=ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            second+=ans[i];</span><br><span class="line">        &#125;</span><br><span class="line">        maximize=second-first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;minimize&lt;&lt;<span class="string">" "</span>&lt;&lt;maximize;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1105-Spiral-Matrix-25-模拟"><a href="#1105-Spiral-Matrix-25-模拟" class="headerlink" title="1105. Spiral Matrix (25) [模拟]"></a>1105. Spiral Matrix (25) [模拟]</h1><p>螺旋矩阵的遍历访问赋值不清楚。<br>需要重点再看看理解下！</p>
<h1 id="1101-Quick-Sort-25-快速排序"><a href="#1101-Quick-Sort-25-快速排序" class="headerlink" title="1101. Quick Sort (25) [快速排序]"></a>1101. Quick Sort (25) [快速排序]</h1><p>漏掉了一点：当当前元素没有变化并且它左边的所有值的最⼤值都⽐它⼩的时候就可以认为它⼀定是主元。<br>有个格式错误的点！貌似是当元素为0时，结果的那一行需要直接空出！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    ans = temp;</span><br><span class="line">    sort(ans.begin(),ans.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> maxNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==temp[i] &amp;&amp; temp[i]&gt;maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp[i]&gt;maxNum) maxNum = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,result.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,result[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1098-Insertion-or-Heap-Sort-25-分"><a href="#1098-Insertion-or-Heap-Sort-25-分" class="headerlink" title="1098 Insertion or Heap Sort (25 分)"></a>1098 Insertion or Heap Sort (25 分)</h1><p>大根堆向下调整出了一点问题。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high &amp;&amp; b[j]&lt;b[j+<span class="number">1</span>]) j=j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=b[j]) <span class="keyword">break</span>;</span><br><span class="line">        swap(b[i],b[j]);</span><br><span class="line">        i=j;</span><br><span class="line">        j=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完整算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span>&lt;=high &amp;&amp; b[j]&lt;b[j+<span class="number">1</span>]) j=j+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i]&gt;=b[j]) <span class="keyword">break</span>;</span><br><span class="line">        swap(b[i],b[j]);</span><br><span class="line">        i=j;</span><br><span class="line">        j=<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; origin(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sorted1(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;origin[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sorted1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n &amp;&amp; sorted1[j]==sorted1[<span class="number">0</span>];j++);</span><br><span class="line">    <span class="keyword">if</span>(sorted1[<span class="number">0</span>]&gt;sorted1[j])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Heap Sort\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> temp = sorted1[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span>(pos=<span class="number">0</span>;pos&lt;sorted1.size() &amp;&amp; sorted1[pos]&lt;=temp;pos++);</span><br><span class="line">        pos--;</span><br><span class="line">        swap(sorted1[<span class="number">0</span>],sorted1[pos]);</span><br><span class="line">        downAdjust(sorted1,<span class="number">0</span>,pos<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sorted1.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,sorted1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Insertion Sort\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="keyword">for</span>(pos=<span class="number">0</span>;pos&lt;sorted1.size()<span class="number">-1</span> &amp;&amp; sorted1[pos]&lt;=sorted1[pos+<span class="number">1</span>];pos++);</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==pos) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(sorted1[i]&gt;sorted1[pos] &amp;&amp; flag)</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,sorted1[pos]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,sorted1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1083-List-Grades-25-排序"><a href="#1083-List-Grades-25-排序" class="headerlink" title="1083. List Grades (25) [排序]"></a>1083. List Grades (25) [排序]</h1><p>简单的sort<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.grade&gt;b.grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; info(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %s %d"</span>,&amp;info[i].name,&amp;info[i].id,&amp;info[i].grade);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> up,down;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;down,&amp;up);</span><br><span class="line">    sort(info.begin(),info.end(),cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;info.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(info[i].grade&gt;=down &amp;&amp; info[i].grade&lt;=up)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s %s\n"</span>,info[i].name,info[i].id);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"NONE\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1080-Graduate-Admission-30-排序"><a href="#1080-Graduate-Admission-30-排序" class="headerlink" title="1080. Graduate Admission (30) [排序]"></a>1080. Graduate Admission (30) [排序]</h1><p>超高兴啊！仔细分析自己写出来的，居然没超时，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> ge;</span><br><span class="line">    <span class="keyword">int</span> gf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.gf != b.gf) <span class="keyword">return</span> a.gf&gt;b.gf;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.ge&gt;b.ge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; choice(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; appli;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; school(m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; admit[<span class="number">110</span>];</span><br><span class="line">    <span class="keyword">int</span> ge,gi,gf,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;school[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;ge,&amp;gi);</span><br><span class="line">        gf=(ge+gi)/<span class="number">2</span>;</span><br><span class="line">        appli.push_back(&#123;i,ge,gf&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">            choice[i].push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(appli.begin(),appli.end(),cmp);</span><br><span class="line">    ge=appli[<span class="number">0</span>].ge;gf=appli[<span class="number">0</span>].gf;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; same;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;appli.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id = appli[i].num;</span><br><span class="line">        <span class="keyword">if</span>(appli[i].gf == gf &amp;&amp; appli[i].ge == ge)</span><br><span class="line">        &#123;</span><br><span class="line">            same.push_back(id);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;same.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;choice[same[j]].size();h++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(school[choice[same[j]][h]]&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        admit[choice[same[j]][h]].push_back(same[j]);</span><br><span class="line">                        cnt[choice[same[j]][h]]++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it:cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(school[it.first]-it.second&lt;<span class="number">0</span>) school[it.first]=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> school[it.first]=school[it.first]-it.second;</span><br><span class="line">                cnt[it.first] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            same.clear();</span><br><span class="line">            same.push_back(id);</span><br><span class="line">            gf=appli[i].gf;ge=appli[i].ge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==appli.size()<span class="number">-1</span> &amp;&amp; !same.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;same.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;choice[same[j]].size();h++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(school[choice[same[j]][h]]&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        admit[choice[same[j]][h]].push_back(same[j]);</span><br><span class="line">                        cnt[choice[same[j]][h]]++;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(admit[i].empty()) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sort(admit[i].begin(),admit[i].end());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;admit[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,admit[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1075-PAT-Judge-25-排序"><a href="#1075-PAT-Judge-25-排序" class="headerlink" title="1075. PAT Judge (25) [排序]"></a>1075. PAT Judge (25) [排序]</h1><p>题目抠字眼。。。。被搞懵了，最后找出来了错误改正了，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> perfect;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.sum != b.sum) <span class="keyword">return</span> a.sum&gt;b.sum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.perfect != b.perfect) <span class="keyword">return</span> a.perfect&gt;b.perfect;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;k,&amp;m);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; perfect(n+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; sumscore;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; problem(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) problem[i].resize(k+<span class="number">1</span>,<span class="number">-2</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; full(k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;full[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id,pnum,pscore;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;id,&amp;pnum,&amp;pscore);</span><br><span class="line">        <span class="keyword">if</span>(problem[id][pnum] &lt; pscore)</span><br><span class="line">        &#123;</span><br><span class="line">            problem[id][pnum] = pscore;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> score=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(problem[i][j]!=<span class="number">-2</span> &amp;&amp; problem[i][j] != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(problem[i][j] == full[j]) perfect[i]++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                score+=problem[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            sumscore.push_back(&#123;i,score,perfect[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(sumscore.begin(),sumscore.end(),cmp);</span><br><span class="line">    <span class="keyword">int</span> ran=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sumscore.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre!=sumscore[i].sum)</span><br><span class="line">        &#123;</span><br><span class="line">            ran=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %05d %d"</span>,ran,sumscore[i].id,sumscore[i].sum);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(problem[sumscore[i].id][j] != <span class="number">-2</span> &amp;&amp; problem[sumscore[i].id][j] != <span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" %d"</span>,problem[sumscore[i].id][j]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(problem[sumscore[i].id][j] == <span class="number">-2</span>) <span class="built_in">printf</span>(<span class="string">" -"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        pre = sumscore[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1070-Mooncake-25-贪⼼算法"><a href="#1070-Mooncake-25-贪⼼算法" class="headerlink" title="1070. Mooncake (25) [贪⼼算法]"></a>1070. Mooncake (25) [贪⼼算法]</h1><p>简单的计算利益然后排序选取的贪心算法。AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> ton;</span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    <span class="keyword">double</span> profit;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.profit&gt;b.profit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,need;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;need);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; tons(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; prices(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;tons[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; profits;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        profits.push_back(&#123;tons[i],prices[i],prices[i]/tons[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(profits.begin(),profits.end(),cmp);</span><br><span class="line">    <span class="keyword">double</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;profits.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tempton=profits[i].ton;</span><br><span class="line">        <span class="keyword">if</span>(need&gt;tempton)</span><br><span class="line">        &#123;</span><br><span class="line">            need-=tempton;</span><br><span class="line">            sum+=profits[i].price;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum+=profits[i].profit*need;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1067-Sort-with-Swap-0-25-贪⼼算法"><a href="#1067-Sort-with-Swap-0-25-贪⼼算法" class="headerlink" title="1067. Sort with Swap(0,*) (25) [贪⼼算法]"></a>1067. Sort with Swap(0,*) (25) [贪⼼算法]</h1><p>需要注意的是，本题实质上只用一个记录位置的数组即可处理，不需要我一开始想的建好多个vector然后排序啥的，只需要不断地swap判断交换位置。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> pos[<span class="number">100010</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        pos[t]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(pos[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            swap(pos[<span class="number">0</span>],pos[pos[<span class="number">0</span>]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(pos[<span class="number">0</span>],pos[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1065-A-B-and-C-64bit-20-模拟"><a href="#1065-A-B-and-C-64bit-20-模拟" class="headerlink" title="1065. A+B and C (64bit) (20) [模拟]"></a>1065. A+B and C (64bit) (20) [模拟]</h1><p>不熟悉longlong的范围和溢出时的情况。。。</p>
<hr>
<p>因为A、B的⼤⼩为[-2^63, 2^63]，⽤long long 存储A和B的值，以及他们相加的值sum：</p>
<p>如果A &gt; 0, B &lt; 0 或者 A &lt; 0, B &gt; 0，sum是不可能溢出的</p>
<p>如果A &gt; 0, B &gt; 0，sum可能会溢出，sum范围理应为(0, 2^64 – 2]，溢出得到的结果应该是[-2^63, -2]是个负数，所以sum &lt; 0时候说明溢出了</p>
<p>如果A &lt; 0, B &lt; 0，sum可能会溢出，同理，sum溢出后结果是⼤于0的，所以sum &gt; 0 说明溢出了</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a,b,c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> sum = a+b;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">0</span> &amp;&amp; b&gt;<span class="number">0</span> &amp;&amp; sum&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>,i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&lt;<span class="number">0</span> &amp;&amp; b&lt;<span class="number">0</span> &amp;&amp; sum&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>,i);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;c) <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>,i);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1062-Talent-and-Virtue-25-排序"><a href="#1062-Talent-and-Virtue-25-排序" class="headerlink" title="1062. Talent and Virtue (25) [排序]"></a>1062. Talent and Virtue (25) [排序]</h1><p>简单的sort问题，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> virtue;</span><br><span class="line">    <span class="keyword">int</span> talent;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.level!=b.level) <span class="keyword">return</span> a.level&lt;b.level;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.sum != b.sum) <span class="keyword">return</span> a.sum&gt;b.sum;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.virtue != b.virtue) <span class="keyword">return</span> a.virtue&gt;b.virtue;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,l,h;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;l,&amp;h);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id,v,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;id,&amp;v,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(v&lt;l || t&lt;l) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v&gt;=h &amp;&amp; t&gt;=h) ans.push_back(&#123;id,v,t,v+t,<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v&gt;=h &amp;&amp; t&lt;h) ans.push_back(&#123;id,v,t,v+t,<span class="number">2</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(v&lt;h &amp;&amp; t&lt;h &amp;&amp; v&gt;=t)  ans.push_back(&#123;id,v,t,v+t,<span class="number">3</span>&#125;);</span><br><span class="line">            <span class="keyword">else</span> ans.push_back(&#123;id,v,t,v+t,<span class="number">4</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%08d %d %d\n"</span>,ans[i].id,ans[i].virtue,ans[i].talent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1055-The-World’s-Richest-25-排序"><a href="#1055-The-World’s-Richest-25-排序" class="headerlink" title="1055. The World’s Richest (25) [排序]"></a>1055. The World’s Richest (25) [排序]</h1><p>/<em>分析：不能先排序然后根据每⼀个条件再新建⼀个数组、对新数组排序的⽅法，这样测试点2会超时～因为n和m的悬殊太⼤了，n有10的5次⽅，m却只有100个。所以先把所有的⼈按照财富值排序，再建⽴⼀个数组book标记每个年龄段拥有的⼈的数量，遍历数组并统计相应年龄的⼈数，当当前年龄的⼈的数量不超过100的时候压⼊新的数组，多出来的不要压⼊新数组中（也就是说只取每个年龄的前100名，因为⼀个年龄段最⼩的就是⼀个年龄，即使这样也不会超过100个需要输出），再从这个新的数组⾥⾯取符合相应年龄的⼈的信息～～</em>/<br><strong>然而把string换成字符数组，cin改成scanf后。。。我的原方法不超时了</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> wealth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.wealth!=b.wealth) <span class="keyword">return</span> a.wealth&gt;b.wealth;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.age != b.age) <span class="keyword">return</span> a.age&lt;b.age;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.id,b.id)&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> id[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> age,weal;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>,&amp;ans[i].id,&amp;ans[i].age,&amp;ans[i].wealth);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case #%d:\n"</span>,i);</span><br><span class="line">        <span class="keyword">int</span> pos,l,h;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;pos,&amp;l,&amp;h);</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ans.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;=pos) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans[j].age&gt;=l &amp;&amp; ans[j].age&lt;=h)</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s %d %d\n"</span>,ans[j].id,ans[j].age,ans[j].wealth);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"None\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1046-Shortest-Distance-20-模拟"><a href="#1046-Shortest-Distance-20-模拟" class="headerlink" title="1046. Shortest Distance (20) [模拟]"></a>1046. Shortest Distance (20) [模拟]</h1><p>我的原始方法最后一个点超时，扣了三分，艹！<br>改用数组记录1到各个点的距离，然后用总环长度同每个点计算得到最短距离的方法处理的，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        ans[i]=sum;</span><br><span class="line">        sum+=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s,e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;e);</span><br><span class="line">        <span class="keyword">if</span>(e==s) <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = min(ans[s]-ans[e],sum-ans[s]+ans[e]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = min(ans[e]-ans[s],sum-ans[e]+ans[s]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1042-Shufling-Machine-20-模拟"><a href="#1042-Shufling-Machine-20-模拟" class="headerlink" title="1042. Shufling Machine (20) [模拟]"></a>1042. Shufling Machine (20) [模拟]</h1><p>简单，AC！一开始碰上了莫名其妙的错误。。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">55</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos(<span class="number">55</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; poker(<span class="number">55</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poker[i]=<span class="string">"S"</span>+to_string(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poker[i+<span class="number">13</span>]=<span class="string">"H"</span>+to_string(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poker[i+<span class="number">26</span>]=<span class="string">"C"</span>+to_string(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">13</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        poker[i+<span class="number">39</span>]=<span class="string">"D"</span>+to_string(i);</span><br><span class="line">    &#125;</span><br><span class="line">    poker[<span class="number">53</span>]=<span class="string">"J1"</span>;poker[<span class="number">54</span>]=<span class="string">"J2"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">54</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pos[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">54</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp=pos[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[temp]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">54</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> t = ans[i];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;poker[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1037-Magic-Coupon-25-贪⼼算法"><a href="#1037-Magic-Coupon-25-贪⼼算法" class="headerlink" title="1037. Magic Coupon (25) [贪⼼算法]"></a>1037. Magic Coupon (25) [贪⼼算法]</h1><p>简单，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nc,np;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nc);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ncpos;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ncneg;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nppos;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; npneg;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nc;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) ncneg.push_back(t);</span><br><span class="line">        <span class="keyword">else</span> ncpos.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;np);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;np;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) npneg.push_back(t);</span><br><span class="line">        <span class="keyword">else</span> nppos.push_back(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ncpos.begin(),ncpos.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    sort(nppos.begin(),nppos.end(),greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    sort(ncneg.begin(),ncneg.end());</span><br><span class="line">    sort(npneg.begin(),npneg.end());</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ncpos.size()&amp;&amp;i&lt;nppos.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=ncpos[i]*nppos[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ncneg.size()&amp;&amp;i&lt;npneg.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=ncneg[i]*npneg[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1038-Recover-the-Smallest-Number-30-分"><a href="#1038-Recover-the-Smallest-Number-30-分" class="headerlink" title="1038 Recover the Smallest Number (30 分)"></a>1038 Recover the Smallest Number (30 分)</h1><p><strong>cmp函数的强化使用！！！</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a,<span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b&lt;b+a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; store(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;store[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(store.begin(),store.end(),cmp);</span><br><span class="line">    <span class="built_in">string</span> sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:store)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(sum[<span class="number">0</span>]==<span class="string">'0'</span> &amp;&amp; sum.length()!=<span class="number">0</span>) sum.erase(sum.begin());</span><br><span class="line">    <span class="keyword">if</span>(sum.length()==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1028-List-Sorting-25-分"><a href="#1028-List-Sorting-25-分" class="headerlink" title="1028 List Sorting (25 分)"></a>1028 List Sorting (25 分)</h1><p>很简单的一个sort题，准备不同的cmp函数即可。AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.name != b.name) <span class="keyword">return</span> a.name &lt; b.name;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp3</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.grade != b.grade) <span class="keyword">return</span> a.grade&lt;b.grade;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ans[i].id&gt;&gt;ans[i].name&gt;&gt;ans[i].grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">1</span>) sort(ans.begin(),ans.end(),cmp1);</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">2</span>) sort(ans.begin(),ans.end(),cmp2);</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">3</span>) sort(ans.begin(),ans.end(),cmp3);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%06d %s %d\n"</span>,ans[i].id,ans[i].name.c_str(),ans[i].grade);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1025-PAT-Ranking-25-分"><a href="#1025-PAT-Ranking-25-分" class="headerlink" title="1025 PAT Ranking (25 分)"></a>1025 PAT Ranking (25 分)</h1><p>也是一个很简单的sort，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">int</span> locationNum;</span><br><span class="line">    <span class="keyword">int</span> localRank;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.grade!=b.grade) <span class="keyword">return</span> a.grade&gt;b.grade;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.id&lt;b.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; temp(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld%d"</span>,&amp;temp[j].id,&amp;temp[j].grade);</span><br><span class="line">            temp[j].locationNum = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(temp.begin(),temp.end(),cmp1);</span><br><span class="line">        <span class="keyword">int</span> ran = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre != temp[j].grade) ran=j+<span class="number">1</span>;</span><br><span class="line">            temp[j].localRank = ran;</span><br><span class="line">            ans.push_back(temp[j]);</span><br><span class="line">            pre = temp[j].grade;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp1);</span><br><span class="line">    <span class="keyword">int</span> ran = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ans.size();j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre != ans[j].grade) ran=j+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%013lld %d %d %d\n"</span>,ans[j].id, ran, ans[j].locationNum,ans[j].localRank);</span><br><span class="line">        pre = ans[j].grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1012-The-Best-Rank-25-排序"><a href="#1012-The-Best-Rank-25-排序" class="headerlink" title="1012. The Best Rank (25) [排序]"></a>1012. The Best Rank (25) [排序]</h1>]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>排序</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结5</title>
    <url>/2019/09/02/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%935/</url>
    <content><![CDATA[<h1 id="1152-Google-Recruitment-20-字符串处理"><a href="#1152-Google-Recruitment-20-字符串处理" class="headerlink" title="1152. Google Recruitment (20) [字符串处理]"></a>1152. Google Recruitment (20) [字符串处理]</h1><p>最后输出的string结果，全部AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">0</span> || temp==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=temp;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;k);</span><br><span class="line">    <span class="built_in">string</span> origin;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;origin;</span><br><span class="line">    <span class="keyword">bool</span> temp = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">string</span> pos;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=l-k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(stoi(origin.substr(i,k))))</span><br><span class="line">        &#123;</span><br><span class="line">            temp = <span class="literal">true</span>;</span><br><span class="line">            pos=origin.substr(i,k);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp) <span class="built_in">cout</span>&lt;&lt;pos;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"404"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1140-Look-and-say-Sequence-20-字符串处理-（太巧妙了）"><a href="#1140-Look-and-say-Sequence-20-字符串处理-（太巧妙了）" class="headerlink" title="1140. Look-and-say Sequence (20) [字符串处理]（太巧妙了）"></a>1140. Look-and-say Sequence (20) [字符串处理]（太巧妙了）</h1><p>最后一个点超时？？？非本人做。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> d;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;d&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;d.length();j=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(k=j;k&lt;d.length() &amp;&amp; d[k]==d[j];k++);</span><br><span class="line">            t+=d[j]+to_string(k-j);</span><br><span class="line">        &#125;</span><br><span class="line">        d = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1108-Finding-Average-20-字符串处理"><a href="#1108-Finding-Average-20-字符串处理" class="headerlink" title="1108. Finding Average (20) [字符串处理]"></a>1108. Finding Average (20) [字符串处理]</h1><p>用的自己的小方法做的，不断if处理，代码量长了点，然后没看清题意，导致一开始一个点没通过。AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//巧妙方法</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line"><span class="built_in">sscanf</span>(a, <span class="string">"%lf"</span>, &amp;temp);</span><br><span class="line"><span class="built_in">sprintf</span>(b, <span class="string">"%.2f"</span>,temp);</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">strlen</span>(a); j++)</span><br><span class="line">    <span class="keyword">if</span>(a[j] != b[j]) flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ans;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cima = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> x = ans[<span class="number">0</span>]==<span class="string">'-'</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=x;j&lt;ans.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(ans[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ans[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cima == <span class="number">1</span>) cnt++;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ans[j]==<span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cima++;</span><br><span class="line">                <span class="keyword">if</span>(cima &gt; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag &amp;&amp; cnt&lt;=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> temp = stof(ans);</span><br><span class="line">            <span class="keyword">if</span>(temp&gt;=<span class="number">-1000</span> &amp;&amp; temp &lt;= <span class="number">1000</span>)</span><br><span class="line">                result.push_back(temp);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERROR: "</span>&lt;&lt;ans&lt;&lt;<span class="string">" is not a legal number"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERROR: "</span>&lt;&lt;ans&lt;&lt;<span class="string">" is not a legal number"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.size()==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"The average of 0 numbers is Undefined"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result.size()==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"The average of %d number is %.2f"</span>,result.size(),result[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> average=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:result)</span><br><span class="line">        &#123;</span><br><span class="line">            average+=it;</span><br><span class="line">        &#125;</span><br><span class="line">        average = average/result.size();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"The average of %d numbers is %.2f"</span>,result.size(),average);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1082-Read-Number-in-Chinese-25-字符串处理"><a href="#1082-Read-Number-in-Chinese-25-字符串处理" class="headerlink" title="1082. Read Number in Chinese (25) [字符串处理]"></a>1082. Read Number in Chinese (25) [字符串处理]</h1><p>不会。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="1077-Kuchiguse-20-字符串处理"><a href="#1077-Kuchiguse-20-字符串处理" class="headerlink" title="1077. Kuchiguse (20) [字符串处理]"></a>1077. Kuchiguse (20) [字符串处理]</h1><p>分析：<br>因为是后缀，反过来⽐较太麻烦，所以每输⼊⼀个字符串，就把它逆序过来再⽐较会⽐较容易～<br>⾸先ans = s；后来每输⼊的⼀个字符串，都和ans⽐较，如果后⾯不相同的就把它截取掉，<br>最后输出ans即可（要逆序输出～，所以先将ans倒置reverse⼀下～）</p>
<h1 id="1073-Scientific-Notation-20-字符串处理"><a href="#1073-Scientific-Notation-20-字符串处理" class="headerlink" title="1073. Scientific Notation (20) [字符串处理]"></a>1073. Scientific Notation (20) [字符串处理]</h1><h1 id="1061-Dating-20-字符串处理"><a href="#1061-Dating-20-字符串处理" class="headerlink" title="1061. Dating (20) [字符串处理]"></a>1061. Dating (20) [字符串处理]</h1><p>忘记分别是从A-N和A-G了，不包括所有大写字母。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="built_in">string</span>&gt; day;</span><br><span class="line">    day[<span class="string">'A'</span>]=<span class="string">"MON"</span>;</span><br><span class="line">    day[<span class="string">'B'</span>]=<span class="string">"TUE"</span>;</span><br><span class="line">    day[<span class="string">'C'</span>]=<span class="string">"WED"</span>;</span><br><span class="line">    day[<span class="string">'D'</span>]=<span class="string">"THU"</span>;</span><br><span class="line">    day[<span class="string">'E'</span>]=<span class="string">"FRI"</span>;</span><br><span class="line">    day[<span class="string">'F'</span>]=<span class="string">"SAT"</span>;</span><br><span class="line">    day[<span class="string">'G'</span>]=<span class="string">"SUN"</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; hour;</span><br><span class="line">    <span class="built_in">string</span> str=<span class="string">"0123456789ABCDEFGHIJKLMN"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hour[str[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> ans,temp;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">    <span class="keyword">int</span> len = min(ans.length(),temp.length());</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[j]==temp[j] &amp;&amp; ans[j]&lt;=<span class="string">'G'</span> &amp;&amp; ans[j]&gt;=<span class="string">'A'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;day[ans[j]]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            pos = j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=pos+<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[j]==temp[j] &amp;&amp; (<span class="built_in">isdigit</span>(ans[j]) || (ans[j]&lt;=<span class="string">'N'</span> &amp;&amp; ans[j]&gt;=<span class="string">'A'</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d:"</span>,hour[ans[j]]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ans;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">    len = min(ans.length(),temp.length());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==temp[i] &amp;&amp; <span class="built_in">isalpha</span>(ans[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02d"</span>,i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1035-Password-20-字符串处理"><a href="#1035-Password-20-字符串处理" class="headerlink" title="1035. Password (20) [字符串处理]"></a>1035. Password (20) [字符串处理]</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; exist;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; day;</span><br><span class="line">    exist.insert(<span class="string">'1'</span>);</span><br><span class="line">    exist.insert(<span class="string">'0'</span>);</span><br><span class="line">    exist.insert(<span class="string">'l'</span>);</span><br><span class="line">    exist.insert(<span class="string">'O'</span>);</span><br><span class="line">    day[<span class="string">'1'</span>]=<span class="string">'@'</span>;</span><br><span class="line">    day[<span class="string">'0'</span>]=<span class="string">'%'</span>;</span><br><span class="line">    day[<span class="string">'l'</span>]=<span class="string">'L'</span>;</span><br><span class="line">    day[<span class="string">'O'</span>]=<span class="string">'o'</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; password;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; name;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> tp,tn,temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tn&gt;&gt;tp;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;tp.length();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(exist.find(tp[j])!=exist.end())</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                temp+=day[tp[j]];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                temp+=tp[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            password.push_back(temp);</span><br><span class="line">            name.push_back(tn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(password.size()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"There is 1 account and no account is modified"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"There are %d accounts and no account is modified"</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;password.size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;password.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;name[i]&lt;&lt;<span class="string">" "</span>&lt;&lt;password[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>字符串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>其它知识点1</title>
    <url>/2019/08/28/%E5%85%B6%E5%AE%83%E7%9F%A5%E8%AF%86%E7%82%B91/</url>
    <content><![CDATA[<h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><ol>
<li>unordered_map存储不容易超时。<br><code>#include &lt;unordered_map&gt;</code></li>
<li><p>排序传参建议⽤引⽤传参，这样更快，虽然有时候不⽤引⽤传参也能通过，但还是尽量⽤，养成好习惯～</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.value != b.value ? a.value &gt; b.value : a.t &lt; b.t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>string转c里的char数组<br><code>s.c_str()</code></p>
</li>
<li><strong>新的遍历容器方法和结构体赋值方法！</strong><br><code>for (auto it : m) ans.push_back({it.first, it.second});</code></li>
<li>除了string输入需要用cin，其它情况输出输入都用cstdio里的函数，这样才不容易超时。</li>
<li>对所有string字母转换为小写字母：<br><code>transform(s.begin(),s.end(),s.begin(),::tolower);</code></li>
<li>⼤⼩写不区分，所以统计之前要先s[i] = tolower(s[i]);</li>
<li>[0-9 A-Z a-z]可以简写为cctype头⽂件⾥⾯的⼀个函数isalnum～～</li>
<li>四舍五入：<br> <code>gi=(int)(gmi*0.4+gfi*0.6+0.5);</code></li>
<li>其它数据转string用<code>string a = to_string(1);</code></li>
<li><p>sscanf() – 从⼀个字符串中读进与指定格式相符的数据</p>
<p>sprintf() – 字符串格式化命令，主要功能是把格式化的数据写⼊某个字符串中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">"%d"</span>,&amp;n);     <span class="comment">//把str中的内容以"%d"的格式输出到n中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">123</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,n);    <span class="comment">//把n中的内容以"%d"的格式输出到str中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>螺旋矩阵的遍历：</p>
<p>按口字形遍历，M*N型（M&gt;=N）矩阵共有M/2+M%2个口字形（层）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> level = m/<span class="number">2</span>+m%<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n - <span class="number">1</span> - i &amp;&amp; t &lt;= N - <span class="number">1</span>; j++)</span><br><span class="line">        b[i][j] = a[t++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= m - <span class="number">2</span> - i &amp;&amp; t &lt;= N - <span class="number">1</span>; j++)</span><br><span class="line">        b[j][n - <span class="number">1</span> - i] = a[t++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i - <span class="number">1</span>; j &gt;= i &amp;&amp; t &lt;= N - <span class="number">1</span>; j--)</span><br><span class="line">        b[m - <span class="number">1</span> - i][j] = a[t++];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">2</span> - i; j &gt;= i + <span class="number">1</span> &amp;&amp; t &lt;= N - <span class="number">1</span>; j--)</span><br><span class="line">        b[j][i] = a[t++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cmp函数的强化使用！！！</strong></p>
<p>不是按照字典序排列就可以的，必须保证两个字符串构成的数字是最⼩的才⾏，所以cmp函数写成return a + b &lt; b + a;的形式，保证它排列按照能够组成的最⼩数字的形式排列。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;a,<span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b&lt;b+a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>strcmp(str1,str2)，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。</p>
</li>
<li><strong>注重先存储，后按条件取值push的思想！</strong></li>
<li>判断是否到输入结束 <code>while(scanf(&quot;%d&quot;, &amp;n) != EOF)</code></li>
<li><p>大整数加法，两个都用string s,t</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = s.length(), carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        s[i] = s[i] + t[i] + carry - <span class="string">'0'</span>;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            s[i] = s[i] - <span class="number">10</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry) s = <span class="string">'1'</span>+s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于某些需要找从第i位后与其不同的第一个位置的地方，可以用如下方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=i;j&lt;length &amp;&amp; d[i]==d[j];j++);</span><br><span class="line">    <span class="comment">//或者用while，在二叉树的前序中序转后序这些题型中用过</span></span><br><span class="line">    <span class="comment">//int j = i;</span></span><br><span class="line">    <span class="comment">//while(j&lt;length &amp;&amp; d[i]==d[j]) j++;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>reverse(it1,it2);的使用。可以将数组指针在[it1,it2)之间的元素反转。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结4</title>
    <url>/2019/08/28/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%934/</url>
    <content><![CDATA[<h1 id="1153-Decode-Registration-Card-of-PAT-25-模拟，排序，map"><a href="#1153-Decode-Registration-Card-of-PAT-25-模拟，排序，map" class="headerlink" title="1153. Decode Registration Card of PAT (25) [模拟，排序，map]"></a>1153. Decode Registration Card of PAT (25) [模拟，排序，map]</h1><p>我一开始想的是所有都用map来存储对应，到时候取值就直接查然后输出，结果被自己绕晕了。<br>吸取教训：先用vector把数据存下来，然后针对不同需要进行遍历存储并排序，输出结果。。。</p>
<h2 id="新知识"><a href="#新知识" class="headerlink" title="新知识"></a>新知识</h2><p><strong>改好之后，最后两个测试点超时了，我减少了cout和cin，改用printf统一输出，然后减少了一次substr的调用，此时只有倒数第二个测试点超时了，最后把所有输出都换成了printf。。。。倒数第二个结点也通过了。。。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; cards;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.score!=b.score) <span class="keyword">return</span> a.score&gt;b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.num&lt;b.num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    cards.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;cards[i].num&gt;&gt;cards[i].score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="built_in">string</span> term;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;type&gt;&gt;term;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Case %d: %d %s\n"</span>,i,type,term.c_str());</span><br><span class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cards.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cards[j].num[<span class="number">0</span>]==term[<span class="number">0</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    ans.push_back(cards[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnum=<span class="number">0</span>,cscore=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cards.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cards[j].num.substr(<span class="number">1</span>,<span class="number">3</span>)==term)</span><br><span class="line">                &#123;</span><br><span class="line">                    cnum++;</span><br><span class="line">                    cscore+=cards[j].score;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnum!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,cnum,cscore);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; sum;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cards.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(cards[j].num.substr(<span class="number">4</span>,<span class="number">6</span>)==term)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum[cards[j].num.substr(<span class="number">1</span>,<span class="number">3</span>)]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it = sum.begin();it!=sum.end();it++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(&#123;it-&gt;first,it-&gt;second&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">        <span class="keyword">if</span>(ans.empty()) <span class="built_in">printf</span>(<span class="string">"NA\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ans.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>,ans[j].num.c_str(),ans[j].score);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1149-Dangerous-Goods-Packaging-25-STL的应⽤"><a href="#1149-Dangerous-Goods-Packaging-25-STL的应⽤" class="headerlink" title="1149. Dangerous Goods Packaging (25) [STL的应⽤]"></a>1149. Dangerous Goods Packaging (25) [STL的应⽤]</h1><p>set，map，vector齐上阵！AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &gt; incom;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        incom[a].insert(b);</span><br><span class="line">        incom[b].insert(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; now(k);</span><br><span class="line">        <span class="keyword">int</span> have[<span class="number">100000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;now[j]);</span><br><span class="line">            have[now[j]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:now)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; temp = incom[it];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it:temp)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(have[it]!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1144-The-Missing-Number-20-STL，map"><a href="#1144-The-Missing-Number-20-STL，map" class="headerlink" title="1144. The Missing Number (20) [STL，map]"></a>1144. The Missing Number (20) [STL，map]</h1><p>一开始用的hash数组，后来发现题目并未规定输入数据的大小，所以容易出现越界的段错误。然后改用map处理，有三个点没通过。思考之后发现，没考虑到输入的数字之间未缺少的情况，这种情况下的输出应该是n+1，更正后AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; have;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">0</span>) have[a] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(have[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"%d"</span>,n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1141-PAT-Ranking-of-Institutions-25-排序，map-STL"><a href="#1141-PAT-Ranking-of-Institutions-25-排序，map-STL" class="headerlink" title="1141. PAT Ranking of Institutions (25) [排序，map STL]"></a>1141. PAT Ranking of Institutions (25) [排序，map STL]</h1><p>有一个结点一直通不过，后来看答案才知道<strong>总加权分数取整数部分是要对最后的总和取整数部分，不能每次都直接⽤int存储，不然会有⼀个3分测试点不通过～</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; schooltoscore;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; schooltonum;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; schools;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; exist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> ss;</span><br><span class="line">    <span class="keyword">int</span> tws;</span><br><span class="line">    <span class="keyword">int</span> ns;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.tws != b.tws) <span class="keyword">return</span> a.tws&gt;b.tws;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.ns != b.ns) <span class="keyword">return</span> a.ns&lt;b.ns;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.ss&lt;b.ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> id,school;</span><br><span class="line">        <span class="keyword">int</span> score;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;id&gt;&gt;score&gt;&gt;school;</span><br><span class="line">        transform(school.begin(),school.end(),school.begin(),::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">'B'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            schooltoscore[school]+=<span class="number">1.0</span>*score/<span class="number">1.5</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(id[<span class="number">0</span>]==<span class="string">'A'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            schooltoscore[school]+=<span class="number">1.0</span>*score;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            schooltoscore[school]+=score*<span class="number">1.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        schooltonum[school]++;</span><br><span class="line">        schools.insert(school);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,schools.size());</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:schools)</span><br><span class="line">    &#123;</span><br><span class="line">        ans.push_back(&#123;it,schooltoscore[it],schooltonum[it]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">    <span class="keyword">int</span> ran = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = ans[<span class="number">0</span>].tws;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i].tws != pre)</span><br><span class="line">        &#123;</span><br><span class="line">            ran =<span class="number">1</span>+i;</span><br><span class="line">            pre = ans[i].tws;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %s %d %d\n"</span>,ran,ans[i].ss.c_str(),ans[i].tws,ans[i].ns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1137-Final-Grading-25-map映射，排序"><a href="#1137-Final-Grading-25-map映射，排序" class="headerlink" title="1137. Final Grading (25) [map映射，排序]"></a>1137. Final Grading (25) [map映射，排序]</h1><p>最后一个点未AC。。。。<br>第二次做，碰到的是小数计算转换成整数的问题，四舍五入。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.g != b.g) <span class="keyword">return</span> a.g&gt;b.g;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.name&lt;b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,m,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;p,&amp;m,&amp;n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; gp,gm,gf;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;score;</span><br><span class="line">        <span class="keyword">if</span>(score&gt;=<span class="number">200</span>) gp[s]=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;score;</span><br><span class="line">        <span class="keyword">if</span>(score==<span class="number">0</span>) gm[s]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> gm[s]=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;score;</span><br><span class="line">        <span class="keyword">if</span>(score==<span class="number">0</span>) gf[s]=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> gf[s]=score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:gp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> gi;</span><br><span class="line">        <span class="keyword">int</span> gmi=gm[it.first];</span><br><span class="line">        <span class="keyword">int</span> gfi=gf[it.first];</span><br><span class="line">        <span class="keyword">if</span>(gmi&gt;gfi)</span><br><span class="line">        &#123;</span><br><span class="line">            gi=(<span class="keyword">int</span>)(gmi*<span class="number">0.4</span>+gfi*<span class="number">0.6</span>+<span class="number">0.5</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            gi=gfi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(gi&gt;=<span class="number">60</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(&#123;gi,it.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d "</span>,ans[i].name.c_str(),gp[ans[i].name]);</span><br><span class="line">        <span class="keyword">if</span>(gm[ans[i].name]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1 "</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(gm[ans[i].name]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>,gm[ans[i].name]);</span><br><span class="line">        <span class="keyword">if</span>(gf[ans[i].name]==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(gf[ans[i].name]==<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,gf[ans[i].name]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d\n"</span>,ans[i].g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1124-Rafle-for-Weibo-Followers-20-map映射"><a href="#1124-Rafle-for-Weibo-Followers-20-map映射" class="headerlink" title="1124. Rafle for Weibo Followers (20) [map映射]"></a>1124. Rafle for Weibo Followers (20) [map映射]</h1><p>easy！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n&gt;&gt;s;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; forwards;</span><br><span class="line">    <span class="keyword">int</span> idx = s;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> id;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;id;</span><br><span class="line">        <span class="keyword">if</span>(i==s &amp;&amp; forwards[id]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            forwards[id]=<span class="number">1</span>;</span><br><span class="line">            s+=n;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==s &amp;&amp; forwards[id]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Keep going..."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1112-Stucked-Keyboard-20-map映射，STL的使⽤"><a href="#1112-Stucked-Keyboard-20-map映射，STL的使⽤" class="headerlink" title="1112. Stucked Keyboard (20) [map映射，STL的使⽤]"></a>1112. Stucked Keyboard (20) [map映射，STL的使⽤]</h1><p>没考虑到前面先出现了符合标准的字符，后序又不符合的情况，加了一个判断的set，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    getchar();</span><br><span class="line">    getline(<span class="built_in">cin</span>,s);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> pre=s[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; happen;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; repeat;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == s[i]) cnt++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt%k != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                happen.insert(pre);</span><br><span class="line">                repeat.erase(pre);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt%k == <span class="number">0</span> &amp;&amp; happen.find(pre) == happen.end())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(pre);</span><br><span class="line">            repeat.insert(pre);</span><br><span class="line">        &#125;</span><br><span class="line">        pre = s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; happen2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(happen2.find(ans[i]) == happen2.end() &amp;&amp; repeat.find(ans[i])!=repeat.end())</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(ans[i]);</span><br><span class="line">            happen2.insert(ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:result) <span class="built_in">printf</span>(<span class="string">"%c"</span>,it);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(happen2.find(s[i])!=happen2.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">            i=i+k<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1095-Cars-on-Campus-30-map的⽤法，排序"><a href="#1095-Cars-on-Campus-30-map的⽤法，排序" class="headerlink" title="1095. Cars on Campus (30) [map的⽤法，排序]"></a>1095. Cars on Campus (30) [map的⽤法，排序]</h1><ol>
<li>⼀开始所有⻋辆的id、时间和是进还是出（进的flag是1，出的flag是-1），对他们排序，先按照⻋牌号排序，再按照来的时间先后排序。</li>
<li>此后就能根据这样的排序后的顺序将所有满⾜条件（合法）的⻋辆进出记录保存到另⼀个数组⾥⾯。这个数组再按照时间先后排序。</li>
<li>因为多次询问值，为了避免超时，可以把他们的⻋辆数cnt数组先算出来。到时候直接取值就会⽐较快速。cnt[i]表示在i下标的记录的时间点的时候⻋辆的数量。数量可以由前⼀个数量+当前⻋辆的flag得到。</li>
<li>因为问询的时候是多个时间点按照从⼩到⼤的顺序，利⽤好这点能避免超时。如果上⼀个查询的index已经被记住，那么下⼀次就只需要从这个index开始找就可以了，避免重复寻找，浪费时间。<br>策略如上。。。总算更正确了。。。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> pn;</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.pn != b.pn) <span class="keyword">return</span> a.pn&lt;b.pn;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.time&lt;b.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">string</span> pn,status;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; park;</span><br><span class="line">    <span class="keyword">int</span> h,m,s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;pn;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>,&amp;h,&amp;m,&amp;s);</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;status;</span><br><span class="line">        park.push_back(&#123;pn,h*<span class="number">3600</span>+m*<span class="number">60</span>+s,status==<span class="string">"in"</span>?<span class="number">1</span>:<span class="number">2</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(park.begin(),park.end(),cmp);</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; parkTime;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(park[i].pn==park[i+<span class="number">1</span>].pn &amp;&amp; park[i].status==<span class="number">1</span> &amp;&amp; park[i+<span class="number">1</span>].status==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(park[i]);</span><br><span class="line">            ans.push_back(park[i+<span class="number">1</span>]);</span><br><span class="line">            parkTime[park[i].pn]+=(park[i+<span class="number">1</span>].time-park[i].time);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>,pos=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; maxPark;</span><br><span class="line">    <span class="keyword">int</span> maxtime=<span class="number">0</span>;</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>,&amp;h,&amp;m,&amp;s);</span><br><span class="line">        <span class="keyword">int</span> line = h*<span class="number">3600</span> + m*<span class="number">60</span> +s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=pos;j&lt;ans.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(line&gt;=ans[j].time)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans[j].status==<span class="number">1</span>) cnt++;</span><br><span class="line">                <span class="keyword">else</span> cnt--;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:parkTime)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it.second &gt; maxtime)</span><br><span class="line">        &#123;</span><br><span class="line">            maxtime = it.second;</span><br><span class="line">            maxPark.clear();</span><br><span class="line">            maxPark.insert(it.first);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it.second == maxtime)</span><br><span class="line">        &#123;</span><br><span class="line">            maxPark.insert(it.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:maxPark) <span class="built_in">printf</span>(<span class="string">"%s "</span>,it.c_str());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>,maxtime/<span class="number">3600</span>,maxtime/<span class="number">60</span>%<span class="number">60</span>,maxtime%<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="1071-Speech-Patterns-25-map映射，STL的使⽤"><a href="#1071-Speech-Patterns-25-map映射，STL的使⽤" class="headerlink" title="1071. Speech Patterns (25) [map映射，STL的使⽤]"></a>1071. Speech Patterns (25) [map映射，STL的使⽤]</h1><p>一开始用transform，有三个答案都超时了，后来对每个字母用tolower，超时的通过了。还有用cctype里的isalnum判断的方法需要注意！最后忘记n-1时把单词加入了。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> origin;</span><br><span class="line">    getline(<span class="built_in">cin</span>,origin);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; maxWord;</span><br><span class="line">    <span class="keyword">int</span> maxtime=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; times;</span><br><span class="line">    <span class="built_in">string</span> temp=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalnum</span>(origin[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            temp+=<span class="built_in">tolower</span>(origin[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp!=<span class="string">""</span>)times[temp]++;</span><br><span class="line">            temp=<span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==origin.size()<span class="number">-1</span> &amp;&amp; temp != <span class="string">""</span>) times[temp]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:times)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it.second &gt; maxtime)</span><br><span class="line">        &#123;</span><br><span class="line">            maxtime = it.second;</span><br><span class="line">            maxWord.clear();</span><br><span class="line">            maxWord.insert(it.first);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(it.second == maxtime) maxWord.insert(it.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:maxWord)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s "</span>,it.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,maxtime);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1054-The-Dominant-Color-20-map映射，STL的使⽤"><a href="#1054-The-Dominant-Color-20-map映射，STL的使⽤" class="headerlink" title="1054. The Dominant Color (20) [map映射，STL的使⽤]"></a>1054. The Dominant Color (20) [map映射，STL的使⽤]</h1><p>AC！差一点超了。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;temp);</span><br><span class="line">            cnt[temp]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxtime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> half = n*m/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:cnt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it.second &gt; half &amp;&amp; it.second&gt;maxtime)</span><br><span class="line">        &#123;</span><br><span class="line">            result=it.first;</span><br><span class="line">            maxtime=it.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1047-Student-List-for-Course-25-不定⻓数组vector，STL的使⽤"><a href="#1047-Student-List-for-Course-25-不定⻓数组vector，STL的使⽤" class="headerlink" title="1047. Student List for Course (25) [不定⻓数组vector，STL的使⽤]"></a>1047. Student List for Course (25) [不定⻓数组vector，STL的使⽤]</h1><p>一开始用set，结果超时了？？？后来用vector+sort替代了set，输出正确！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; course[<span class="number">2550</span>];</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;name;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            course[temp].push_back(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,i,course[i].size());</span><br><span class="line">        sort(course[i].begin(),course[i].end());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:course[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,it.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1039-Course-List-for-Student-25-不定⻓数组vector，STL的使⽤"><a href="#1039-Course-List-for-Student-25-不定⻓数组vector，STL的使⽤" class="headerlink" title="1039. Course List for Student (25) [不定⻓数组vector，STL的使⽤]"></a>1039. Course List for Student (25) [不定⻓数组vector，STL的使⽤]</h1><p>直接map+内嵌vector暴力解决。。。时间差一点爆了。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; course;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ni,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;c,&amp;ni);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ni;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> temp;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">            course[temp].push_back(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        sort(course[temp].begin(),course[temp].end());</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="string">" "</span>&lt;&lt;course[temp].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:course[temp])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;it;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1022-Digital-Library-30-map映射，STL的使⽤"><a href="#1022-Digital-Library-30-map映射，STL的使⽤" class="headerlink" title="1022. Digital Library (30) [map映射，STL的使⽤]"></a>1022. Digital Library (30) [map映射，STL的使⽤]</h1><p>一开始用拆词法漏掉了最后一个string，修改后最后一个点超时。结构体的方法难以优化，使用大量map进行求解的方法据说能降低时间复杂度。。。<br>使用大量map求解成功！不贴代码了。。。用函数可以精简代码的。。。</p>
]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>排序</tag>
        <tag>map</tag>
        <tag>STL的应用</tag>
      </tags>
  </entry>
  <entry>
    <title>hash平方探测法和质数表的构造</title>
    <url>/2019/08/27/hash%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95%E5%92%8C%E8%B4%A8%E6%95%B0%E8%A1%A8%E7%9A%84%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<h1 id="是否是质数判断"><a href="#是否是质数判断" class="headerlink" title="是否是质数判断"></a>是否是质数判断</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isprime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找比tsize大的最小质数</span></span><br><span class="line"><span class="keyword">while</span>(!isprime(tsize)) tsize++;</span><br></pre></td></tr></table></figure>
<h1 id="平方探测法"><a href="#平方探测法" class="headerlink" title="平方探测法"></a>平方探测法</h1><p>⽤平⽅探测法插⼊数字a，每次<code>pos = (a + j * j) % tsize</code>，j是从0～tsize-1的数字，如果当前位置可以插⼊就将a赋值给v[pos]，如果⼀次都没有能够插⼊成功就输出”X cannot be inserted.”。其次计算平均查找时间，每次<br>计算<code>pos = (a + j * j) % tsize</code>，其中j &lt;= tsize，如果v[pos]处正是a则查找到了，则退出循环，如果v[pos]处不存在数字表示没查找到，那么也要退出循环。每次查找的时候，退出循环之前的j就是这个数字的查找⻓度。</p>
<h1 id="例题1145"><a href="#例题1145" class="headerlink" title="例题1145"></a>例题1145</h1>]]></content>
      <tags>
        <tag>hash</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结3</title>
    <url>/2019/08/27/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%933/</url>
    <content><![CDATA[<h1 id="1154-Vertex-Coloring-25-set-hash"><a href="#1154-Vertex-Coloring-25-set-hash" class="headerlink" title="1154. Vertex Coloring (25) [set,hash]"></a>1154. Vertex Coloring (25) [set,hash]</h1><p>挺简单的题，就是使用hash来记录颜色，看相连的点是否有同色，并统计上色数。<br>第一次做的时候使用的是int型数组来记录颜色是否已经出现，用一个单独的变量统计数量，但是测试点2出现了段错误，后来换成了用set来记录颜色，set.size()即为颜色数，AC了！<br>推测测试点2的错误是由于kind能够存的颜色号太大导致越界了，以后也要注意！段错误大多数是因为越界造成的！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10100</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxn];</span><br><span class="line"><span class="keyword">int</span> color[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; kind;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        Adj[b].push_back(a);</span><br><span class="line">        Adj[a].push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fill(color,color+maxn,<span class="number">-1</span>);</span><br><span class="line">        kind.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            color[j] = temp;</span><br><span class="line">            <span class="keyword">if</span>(kind.find(temp)==kind.end())</span><br><span class="line">            &#123;</span><br><span class="line">                kind.insert(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> now = color[j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;Adj[j].size();t++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(now == color[Adj[j][t]])</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"%d-coloring\n"</span>,kind.size());</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1145-Hashing-–-Average-Search-Time-25-哈希映射，哈希表，平⽅探测法"><a href="#1145-Hashing-–-Average-Search-Time-25-哈希映射，哈希表，平⽅探测法" class="headerlink" title="1145. Hashing – Average Search Time (25) [哈希映射，哈希表，平⽅探测法]"></a>1145. Hashing – Average Search Time (25) [哈希映射，哈希表，平⽅探测法]</h1><p>没看懂这句话的意思“Quadratic probing (with positive increments only)”<br>probing：探测<br>quadratic：平方的，二次的<br>对于平方探测法也不太了解。</p>
<h1 id="1134-Vertex-Cover-25-hash散列"><a href="#1134-Vertex-Cover-25-hash散列" class="headerlink" title="1134. Vertex Cover (25) [hash散列]"></a>1134. Vertex Cover (25) [hash散列]</h1><p>我先标记每条边，然后用set进行计数，最后比较边数和set的大小进行判断输出。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,e;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; edges;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        Node temp;</span><br><span class="line">        temp.v = b;</span><br><span class="line">        temp.e = i;</span><br><span class="line">        Adj[a].push_back(temp);</span><br><span class="line">        temp.v = a;</span><br><span class="line">        Adj[b].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nv;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nv);</span><br><span class="line">        edges.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nv;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;Adj[t].size();h++)</span><br><span class="line">            &#123;</span><br><span class="line">                edges.insert(Adj[t][h].e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(edges.size() == m) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1129-Recommendation-System-25-set的应⽤，运算符重载"><a href="#1129-Recommendation-System-25-set的应⽤，运算符重载" class="headerlink" title="1129. Recommendation System (25) [set的应⽤，运算符重载]"></a>1129. Recommendation System (25) [set的应⽤，运算符重载]</h1><p>set的使用不熟练，还有运算符的重载。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">50010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,t;</span><br><span class="line">    Node(<span class="keyword">int</span> val,<span class="keyword">int</span> ti):v(val),t(ti)&#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node n1,Node n2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n1.t!=n2.t) <span class="keyword">return</span> n1.t&gt;n2.t;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> n1.v&lt;n2.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;Node&gt; items;</span><br><span class="line"><span class="keyword">int</span> times[maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    fill(times,times+maxv,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">    times[temp]++;</span><br><span class="line">    items.insert(Node(temp,times[temp]));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:"</span>,temp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = items.begin();it!=items.end();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==k) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,(*it).v);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        items.erase(Node(temp,times[temp]));</span><br><span class="line">        times[temp]++;</span><br><span class="line">        items.insert(Node(temp,times[temp]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1121-Damn-Single-25-set的应⽤"><a href="#1121-Damn-Single-25-set的应⽤" class="headerlink" title="1121. Damn Single (25) [set的应⽤]"></a>1121. Damn Single (25) [set的应⽤]</h1><p>答案的思路和我的一样，我一开始犯迷糊了。。。开hash数组就完事了！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">500100</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; single;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">int</span> couple[maxv];</span><br><span class="line"><span class="keyword">int</span> hashMap[maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    fill(couple,couple+maxv,<span class="number">-1</span>);</span><br><span class="line">    fill(hashMap,hashMap+maxv,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p1,p2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;p1,&amp;p2);</span><br><span class="line">        couple[p1]=p2;</span><br><span class="line">        couple[p2]=p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        hashMap[n]=<span class="number">1</span>;</span><br><span class="line">        s.push_back(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(couple[s[i]] == <span class="number">-1</span>) single.insert(s[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(hashMap[couple[s[i]]] == <span class="number">-1</span>) single.insert(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,single.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = single.begin();it!=single.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it!=single.begin()) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%05d"</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1120-Friend-Numbers-20-set的应⽤"><a href="#1120-Friend-Numbers-20-set的应⽤" class="headerlink" title="1120. Friend Numbers (20) [set的应⽤]"></a>1120. Friend Numbers (20) [set的应⽤]</h1><p>很简单的一道set应用题，但是我的while循环判断条件出错了，导致最后一个点没过。后来改好了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">while</span>(temp != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += temp%<span class="number">10</span>;</span><br><span class="line">            temp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        id.insert(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,id.size());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it=id.begin();it!=id.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it!=id.begin()) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1092-To-Buy-or-Not-to-Buy-20-Hash散列"><a href="#1092-To-Buy-or-Not-to-Buy-20-Hash散列" class="headerlink" title="1092. To Buy or Not to Buy (20) [Hash散列]"></a>1092. To Buy or Not to Buy (20) [Hash散列]</h1><p>AC! 简单的题，第一次忘记加过重复的数据了。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> beeds[<span class="number">1010</span>],cnt[<span class="number">1010</span>],vis[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sell,need;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;sell&gt;&gt;need;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sell.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        beeds[sell[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> loss=<span class="number">0</span>,redu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;need.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt[need[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;need.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t = need[i];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[t]==<span class="number">0</span>) temp = beeds[t]-cnt[t];</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            loss+=(-temp);</span><br><span class="line">        &#125;</span><br><span class="line">        vis[t] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(loss != <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"No %d"</span>,loss);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Yes %d"</span>,sell.size()-need.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1084-Broken-Keyboard-20-Hash散列-（新知识！！！）"><a href="#1084-Broken-Keyboard-20-Hash散列-（新知识！！！）" class="headerlink" title="1084. Broken Keyboard (20) [Hash散列]（新知识！！！）"></a>1084. Broken Keyboard (20) [Hash散列]（新知识！！！）</h1><p><code>#include&lt;cctype&gt;   char a = &#39;a&#39;; char b = toupper(a);</code><br>将字符转换成大写！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> exist[<span class="number">1010</span>],repeat[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> origin,type;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;origin&gt;&gt;type;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;type.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        exist[<span class="built_in">toupper</span>(type[i])] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> tt = <span class="built_in">toupper</span>(origin[i]);</span><br><span class="line">        <span class="keyword">if</span>(repeat[tt]==<span class="number">0</span> &amp;&amp; exist[tt] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;tt;</span><br><span class="line">            repeat[tt]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1078-Hashing-25-分"><a href="#1078-Hashing-25-分" class="headerlink" title="1078 Hashing (25 分)"></a>1078 Hashing (25 分)</h1><p>1145的简化版，isPrime的质数判断函数没写对。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> table[maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;=a;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(!isPrime(m)) m++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = (temp+i*i)%m;</span><br><span class="line">            <span class="keyword">if</span>(table[pos]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,pos);</span><br><span class="line">                table[pos]=<span class="number">1</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">if</span>(i!=n<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1063-Set-Similarity-25-集合set，STL的使⽤"><a href="#1063-Set-Similarity-25-集合set，STL的使⽤" class="headerlink" title="1063. Set Similarity (25) [集合set，STL的使⽤]"></a>1063. Set Similarity (25) [集合set，STL的使⽤]</h1><p>AC！一开始建了一个hash数组，后来发现太大了，于是改用纯set方法做的。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; input[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> inter;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;inter);</span><br><span class="line">            input[i].insert(inter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = input[a].begin();it!=input[a].end();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[b].find(*it)!=input[b].end()) cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1.0</span>*cnt/(input[a].size()+input[b].size()-cnt)*<span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.1f%\n"</span>,result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1050-String-Subtraction-20-Hash散列"><a href="#1050-String-Subtraction-20-Hash散列" class="headerlink" title="1050. String Subtraction (20) [Hash散列]"></a>1050. String Subtraction (20) [Hash散列]</h1><p>c++读取一行元素的方法要注意！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> exist[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getline(<span class="built_in">cin</span>,s1);</span><br><span class="line">    getline(<span class="built_in">cin</span>,s2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        exist[s2[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s1.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(exist[s1[i]]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1048-Find-Coins-25-Hash散列"><a href="#1048-Find-Coins-25-Hash散列" class="headerlink" title="1048. Find Coins (25) [Hash散列]"></a>1048. Find Coins (25) [Hash散列]</h1><p>有一些考虑不周全的小问题，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> exist[<span class="number">1010</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; have;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">        exist[temp]++;</span><br><span class="line">        have.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">-1</span>,b=<span class="number">-1</span>;</span><br><span class="line">    sort(have.begin(),have.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;have.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a = have[i];</span><br><span class="line">        exist[a]--;</span><br><span class="line">        <span class="keyword">if</span>(exist[m-a]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b=m-a;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Solution"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>&lt;&lt;b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1041-Be-Unique-20-Hash散列"><a href="#1041-Be-Unique-20-Hash散列" class="headerlink" title="1041. Be Unique (20) [Hash散列]"></a>1041. Be Unique (20) [Hash散列]</h1><p>题目没看懂。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">AC</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>hash</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title>容易忘记的小知识</title>
    <url>/2019/08/18/%E5%AE%B9%E6%98%93%E5%BF%98%E8%AE%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="琐碎的一些东西"><a href="#琐碎的一些东西" class="headerlink" title="琐碎的一些东西"></a>琐碎的一些东西</h1><ol>
<li>对 char c[15] 进⾏ sort 排序的 cmp(char a[], char b[]) 函数要这样写： strcmp(a, b) &lt; 0 ，因为 strcmp 返回的不是 -1 0 1 ⽽是 等于0 ⼩于0 ⼤于0 的某个值， strcmp 在头⽂件 #include &lt;string.h&gt; ⾥⾯.</li>
<li>移除字符串s的第⼀个字符： s.earse(s.begin()); 在字符串 s 前⾯增加 n 个 0 ： s.insert(0, n, ‘0’);</li>
<li>给⼀些数字字符串，求这些字符串拼接起来能够构成的最⼩的数字的⽅式：⽤ cmp 函数就能解决： bool cmp(string a, string b) {return a + b &lt; b + a;}</li>
<li>⽤数组 hash[26] 或者 hash[10] 保存某个字⺟或者数字出现的次数/是否曾经出现过；⽤ hash[256] 保存某个 ASCII码 字符是否出现过， exist[10000] 、 cnt[10000] 同理</li>
<li>题⽬输⼊中所给的a b区间可能a和b给的顺序反了，要⽐᫾⼀下a和b的⼤⼩，如果 a&gt;b 记得swap回来～</li>
<li>要输⼊⼀⾏的数据的话：如果是 string s ，则⽤ getline(cin, s); 在头⽂件 #include <string> ⾥⾯；如果是 char str[100] , 则⽤ cin.getline(str, 100); 在头⽂件 #include <iostream> ⾥⾯，也可以⽤ gets(str);</iostream></string></li>
<li>set 中可以使⽤ rbegin 访问最后⼀个元素，使⽤⽅法： cout &lt;&lt; *s.rbegin();</li>
<li>getline(cin, s); 前⾯如果有换⾏的输⼊，⼀定要在前⾯加上 getchar(); （⽤来读取空格），否则会直接只读⼊要读的字符串前⾯的 \n ～</li>
<li><p>string.find 返回的是下标的值，如果没有，⽤ == string::npos ，如果找到了某个字符，就将这个字符的位置赋值给index，可以这样写代码：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(s.find(<span class="string">'a'</span>, <span class="number">5</span>) != <span class="built_in">string</span>::npos)</span><br><span class="line">    <span class="keyword">int</span> index = s.find(<span class="string">'a'</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使⽤while接收输⼊的两种⽅式</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, n) != EOF) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于下⾯这种：</span></span><br><span class="line"><span class="comment">//因为EOF⼀般为-1，所以~按位取反-1正好是0，就可以退出循环了</span></span><br><span class="line"><span class="comment">//所以也写成下⾯这种情况</span></span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 树的遍历-前序中序转后序：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; end &amp;&amp; pre[root] != in[i]) i++;</span><br><span class="line">    post(root + <span class="number">1</span>, start, i - <span class="number">1</span>);</span><br><span class="line">    post(root + <span class="number">1</span> + i - start, i + <span class="number">1</span>, end);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pre[root]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 树的遍历-后序中序转前序：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; end &amp;&amp; post[root] != in[i]) i++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, post[root]);</span><br><span class="line">    pre(root - <span class="number">1</span> - end + i, start, i - <span class="number">1</span>);</span><br><span class="line">    pre(root - <span class="number">1</span>, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>常用算法</tag>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结2</title>
    <url>/2019/08/15/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%932/</url>
    <content><![CDATA[<h1 id="1150-Travelling-Salesman-Problem-25-图论"><a href="#1150-Travelling-Salesman-Problem-25-图论" class="headerlink" title="1150. Travelling Salesman Problem (25) [图论]"></a>1150. Travelling Salesman Problem (25) [图论]</h1><p>第一次看到的时候以为是要求图中每个点循环一遍回到原处时的最短路径这个np问题，被吓到了，后来自己看题目和给出的输入输出案例，手动画图分析后，发现并不是我想象中的那么难。这个题的本质上就是对几种可能的情况进行分析，然后输出对应情况的语句，而最后求的最接近的路劲值，其实就是在所有成功循环过的路径中挑出长度最小的那条进行相应地输出就行了。AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> N,M,K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp, <span class="keyword">int</span> &amp;dist)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vis[MAXV] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> tDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=temp.size()<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(G[temp[i]][temp[i+<span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[temp[i]]++;</span><br><span class="line">            vis[temp[i+<span class="number">1</span>]]++;</span><br><span class="line">            tDist += G[temp[i]][temp[i+<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dist = tDist;</span><br><span class="line">    <span class="keyword">if</span>(temp[<span class="number">0</span>] != temp[temp.size()<span class="number">-1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">3</span>;</span><br><span class="line">    vis[temp[<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(vis[i] &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            flag = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;N,&amp;M);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s,e,d;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;s,&amp;e,&amp;d);</span><br><span class="line">        G[s][e] = d;</span><br><span class="line">        G[e][s] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;K);</span><br><span class="line">    <span class="keyword">int</span> minDist= <span class="number">1000000000</span>;</span><br><span class="line">    <span class="keyword">int</span> minNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">int</span> n,dist;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        temp.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = judge(temp,dist);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: NA (Not a TS cycle)\n"</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (Not a TS cycle)\n"</span>,i,dist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS cycle)\n"</span>,i,dist);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Path %d: %d (TS simple cycle)\n"</span>,i,dist);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((flag == <span class="number">2</span> || flag == <span class="number">3</span>) &amp;&amp; dist&lt;minDist)</span><br><span class="line">        &#123;</span><br><span class="line">            minDist = dist;</span><br><span class="line">            minNum = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Shortest Dist(%d) = %d"</span>,minNum,minDist);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>以后碰到问题先不要慌，把符合题意的图文先画出来，再结合输入输出案例分析，很多时候实际的解法并不一定是和题意暗示的解法完全一致的</strong></p>
<h1 id="1146-Topological-Order-25-拓扑排序"><a href="#1146-Topological-Order-25-拓扑排序" class="headerlink" title="1146. Topological Order (25) [拓扑排序]"></a>1146. Topological Order (25) [拓扑排序]</h1><p>思路上没有问题，就是在建图的时候设置专门的数组记录每个结点的入度，然后读入待判定的拓扑序列，每个结点判断其输出时的入度是否为0，同时将该结点能到达的结点的入度数减一。<br>出错点是printf时输出的是i而不是result。。。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GT;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tt = GT;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tt[temp[i]] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(G[temp[i]][j]==<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tt[j]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    GT.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s,e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;e);</span><br><span class="line">        G[s][e] = <span class="number">1</span>;</span><br><span class="line">        GT[e]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.resize(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> flag = judge();</span><br><span class="line">        <span class="keyword">if</span>(flag) result.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>,result[i],i!=result.size()<span class="number">-1</span>?<span class="string">" "</span>:<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1142-Maximal-Clique-25-分"><a href="#1142-Maximal-Clique-25-分" class="headerlink" title="1142 Maximal Clique (25 分)"></a>1142 Maximal Clique (25 分)</h1><p>我的思路和答案是一致的，但是我没写出代码。主要是在之后判断是否是maximal，即遍历所有不在集合中的剩余的点，看是否存在⼀个点满⾜和集合中所有的结点相连这块我没想明白。其实可以设置一个数组来标记给出的点，然后访问不在集合中的点，看它们是否都与集合中的点相连。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//关键代码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vis[maxv] =&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vis[temp[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;temp.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Adj[temp[i]][temp[j]] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nv;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i] != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;temp.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(Adj[i][temp[j]] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1126-Eulerian-Path-25-分"><a href="#1126-Eulerian-Path-25-分" class="headerlink" title="1126 Eulerian Path (25 分)"></a>1126 Eulerian Path (25 分)</h1><p>一开始被吓到了，后来读懂题意之后发现做法很简单，但是还是有一个点没过。这题隐含条件是必须是连通图，所以必须要用深搜过一遍。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">510</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[Adj[v][i]] == <span class="literal">false</span>)</span><br><span class="line">            DFS(Adj[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        Adj[a].push_back(b);</span><br><span class="line">        Adj[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Adj[i].size()%<span class="number">2</span> != <span class="number">0</span>) odd++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d%s"</span>,Adj[i].size(),i!=n?<span class="string">" "</span>:<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Non-Eulerian"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(odd==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"Eulerian"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(odd == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"Semi-Eulerian"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"Non-Eulerian"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1122-Hamiltonian-Cycle-25-分"><a href="#1122-Hamiltonian-Cycle-25-分" class="headerlink" title="1122 Hamiltonian Cycle (25 分)"></a>1122 Hamiltonian Cycle (25 分)</h1><p>和前面几题类似的套路，但是我太天真了，一开始没考虑是否将所有点都访问了，而是只考虑了给出序列是否连通的问题。。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> G[maxv][maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;v1,&amp;v2);</span><br><span class="line">        G[v1][v2]=G[v2][v1]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n1;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n1);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(n1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n1;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n1<span class="number">-1</span> != n || temp[<span class="number">0</span>] != temp[n1<span class="number">-1</span>]) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pre = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">            vis[pre] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n1;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(G[pre][temp[j]] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                        flag =<span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = temp[j];</span><br><span class="line">                vis[pre] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n1;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[j]==<span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1111-Online-Map-30-Dijkstra算法-DFS"><a href="#1111-Online-Map-30-Dijkstra算法-DFS" class="headerlink" title="1111. Online Map (30) [Dijkstra算法 + DFS]"></a>1111. Online Map (30) [Dijkstra算法 + DFS]</h1><p>好恶心的题啊。。。。。。<br>用了两次Dijkstra，求两条路径，在求第二条路径的第二条件的时候遇到了阻碍，解决办法是增设一个变量控制比较数组，用来对第二变量进行比较（<strong>注意！此为通法，以后碰到类似情况可以举一反三！</strong>）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> cost[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> c[maxv];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> s,e;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="keyword">int</span> num[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preD(maxv);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rD;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rC;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preC(maxv);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DijkstraD</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+maxv,INF);</span><br><span class="line">    fill(c,c+maxv,INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        preD[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    c[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis &lt; d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v]=d[u]+dis;</span><br><span class="line">                    preD[v]=u;</span><br><span class="line">                    c[v] = c[u]+cost[u][v];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis == d[v] &amp;&amp; c[u]+cost[u][v]&lt;c[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[v] = c[u]+cost[u][v];</span><br><span class="line">                    preD[v]=u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DijkstraC</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(c,c+maxv,INF);</span><br><span class="line">    fill(vis,vis+maxv,<span class="literal">false</span>);</span><br><span class="line">    fill(num,num+maxv,INF);</span><br><span class="line">    c[s]=<span class="number">0</span>;</span><br><span class="line">    num[s]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; c[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = c[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u]= <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c[u]+cost[u][v]&lt;c[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[v] = c[u]+cost[u][v];</span><br><span class="line">                    num[v]=num[u]+<span class="number">1</span>;</span><br><span class="line">                    preC[v]=u;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c[u]+cost[u][v] == c[v] &amp;&amp; num[u]+<span class="number">1</span>&lt;num[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    preC[v]=u;</span><br><span class="line">                    num[v]=num[u]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSD</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e==s)</span><br><span class="line">    &#123;</span><br><span class="line">        rD.push_back(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFSD(preD[e]);</span><br><span class="line">    rD.push_back(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSC</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e==s)</span><br><span class="line">    &#123;</span><br><span class="line">        rC.push_back(e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFSC(preC[e]);</span><br><span class="line">    rC.push_back(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2,o,l,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;v1,&amp;v2,&amp;o,&amp;l,&amp;t);</span><br><span class="line">        Node temp;</span><br><span class="line">        <span class="keyword">if</span>(o==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.v = v2;</span><br><span class="line">            temp.dis = l;</span><br><span class="line">            cost[v1][v2]=t;</span><br><span class="line">            cost[v2][v1]=t;</span><br><span class="line">            Adj[v1].push_back(temp);</span><br><span class="line">            temp.v = v1;</span><br><span class="line">            Adj[v2].push_back(temp);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.v = v2;</span><br><span class="line">            temp.dis = l;</span><br><span class="line">            cost[v1][v2]=t;</span><br><span class="line">            Adj[v1].push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;s,&amp;e);</span><br><span class="line">    DijkstraD(s);</span><br><span class="line">    DijkstraC(s);</span><br><span class="line">    DFSD(e);</span><br><span class="line">    DFSC(e);</span><br><span class="line">    <span class="keyword">if</span>(rD == rC)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d; Time = %d: %d "</span>,d[e],c[e],s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rD.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt; %d%s"</span>,rD[i],i!=rD.size()<span class="number">-1</span>?<span class="string">" "</span>:<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Distance = %d: %d "</span>,d[e],s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rD.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt; %d%s"</span>,rD[i],i!=rD.size()<span class="number">-1</span>?<span class="string">" "</span>:<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\nTime = %d: %d "</span>,c[e],s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rC.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-&gt; %d%s"</span>,rC[i],i!=rC.size()<span class="number">-1</span>?<span class="string">" "</span>:<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1087-All-Roads-Lead-to-Rome-30-分"><a href="#1087-All-Roads-Lead-to-Rome-30-分" class="headerlink" title="1087 All Roads Lead to Rome (30 分)"></a>1087 All Roads Lead to Rome (30 分)</h1><p>之前自己的思路也对，但是代码有点乱，最后在本地可以成功输出结果，但是在OJ上就有各种错误，没查出来问题在哪，于是仿照答案的写法，更改了DFS函数，在DFS中对各项条件进行统计分析，然后获取值输出就行。<strong>下次注意，能在DFS中一块处理的就尽量在DFS中处理完</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; inToS(maxv);</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; sToIn;</span><br><span class="line"><span class="keyword">int</span> weight[maxv];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> d[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp,path;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,happy=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> average=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+maxv,INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v= Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis&lt;d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = d[u]+dis;</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis == d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    temp.push_back(e);</span><br><span class="line">    <span class="keyword">if</span>(e==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            now+=weight[temp[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> nowAver = <span class="number">1.0</span>*now/(temp.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span>(now&gt;happy)</span><br><span class="line">        &#123;</span><br><span class="line">            path = temp;</span><br><span class="line">            happy = now;</span><br><span class="line">            average = nowAver;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(now == happy &amp;&amp; nowAver &gt; average)</span><br><span class="line">        &#123;</span><br><span class="line">            path = temp;</span><br><span class="line">            average = nowAver;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.pop_back();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre[e].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(pre[e][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> start;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k&gt;&gt;start;</span><br><span class="line">    inToS[<span class="number">0</span>] = start;</span><br><span class="line">    sToIn[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> ct;</span><br><span class="line">        <span class="keyword">int</span> wt;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ct&gt;&gt;wt;</span><br><span class="line">        inToS[i]=ct;</span><br><span class="line">        sToIn[ct] = i;</span><br><span class="line">        weight[i]=wt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> c1,c2;</span><br><span class="line">        <span class="keyword">int</span> dd;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c1&gt;&gt;c2&gt;&gt;dd;</span><br><span class="line">        Node temp;</span><br><span class="line">        temp.v = sToIn[c2];</span><br><span class="line">        temp.dis = dd;</span><br><span class="line">        Adj[sToIn[c1]].push_back(temp);</span><br><span class="line">        temp.v = sToIn[c1];</span><br><span class="line">        Adj[sToIn[c2]].push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(<span class="number">0</span>);</span><br><span class="line">    DFS(sToIn[<span class="string">"ROM"</span>]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="string">" "</span>&lt;&lt;d[sToIn[<span class="string">"ROM"</span>]]&lt;&lt;<span class="string">" "</span>&lt;&lt;happy&lt;&lt;<span class="string">" "</span>&lt;&lt;(<span class="keyword">int</span>)average&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;inToS[path[i]];</span><br><span class="line">        <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"-&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1076-Forwards-on-Weibo-30-图的遍历，BFS"><a href="#1076-Forwards-on-Weibo-30-图的遍历，BFS" class="headerlink" title="1076. Forwards on Weibo (30) [图的遍历，BFS]"></a>1076. Forwards on Weibo (30) [图的遍历，BFS]</h1><p>就是一个很简单的BFS遍历图，主要是vis数组的true标志位置不要放错了，AC！与答案不同，我用了一个level数组来记录层数，跳过了Node结构的建立。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxv];</span><br><span class="line"><span class="keyword">int</span> n,l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> level[maxv] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    level[v] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(v);</span><br><span class="line">    vis[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(level[temp]&gt;l) <span class="keyword">break</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[temp].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[Adj[temp][i]] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                level[Adj[temp][i]] = level[temp]+<span class="number">1</span>;</span><br><span class="line">                q.push(Adj[temp][i]);</span><br><span class="line">                vis[Adj[temp][i]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">            Adj[t].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">        BFS(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1072-Gas-Station-30-Dijkstra算法-（存在技术性问题！）"><a href="#1072-Gas-Station-30-Dijkstra算法-（存在技术性问题！）" class="headerlink" title="1072. Gas Station (30) [Dijkstra算法]（存在技术性问题！）"></a>1072. Gas Station (30) [Dijkstra算法]（存在技术性问题！）</h1><p>有以下几个技术上的不足<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将string转换为int型：</span></span><br><span class="line"><span class="built_in">string</span> p1;<span class="keyword">int</span> a;</span><br><span class="line">a = stoi(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//取string从1开始到结尾的字符串</span></span><br><span class="line"><span class="built_in">string</span> p1;</span><br><span class="line">p1 = p1.substr(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//int型数组用fill函数填充值并初始化</span></span><br><span class="line"><span class="keyword">int</span> e[maxn][maxn];</span><br><span class="line">fill(e[<span class="number">0</span>],e[<span class="number">0</span>]+maxn*maxn,INF);</span><br></pre></td></tr></table></figure></p>
<p>其它的问题：一开始做出来了，但是选取的gas station不对，原因是没有看懂题意的第一判定条件，首先需要是离城市最近距离最远的最优先！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm = <span class="number">15</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> e[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> n,m,k,ds;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;ds;</span><br><span class="line">    fill(e[<span class="number">0</span>],e[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> p1,p2;</span><br><span class="line">        <span class="keyword">int</span> dist,a,b;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p1&gt;&gt;p2&gt;&gt;dist;</span><br><span class="line">        <span class="keyword">if</span>(p1[<span class="number">0</span>]==<span class="string">'G'</span>)</span><br><span class="line">            a = n+stoi(p1.substr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a = stoi(p1);</span><br><span class="line">        <span class="keyword">if</span>(p2[<span class="number">0</span>]==<span class="string">'G'</span>)</span><br><span class="line">            b = n+stoi(p2.substr(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = stoi(p2);</span><br><span class="line">        e[a][b]=e[b][a]=dist;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = n+m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i].resize(len,INF);</span><br><span class="line">        d[i][n+i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> vis[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = <span class="number">-1</span> ,MIN=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">1</span>;h&lt;len;h++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[h]==<span class="literal">false</span> &amp;&amp; d[i][h] &lt; MIN)</span><br><span class="line">                &#123;</span><br><span class="line">                    u = h;</span><br><span class="line">                    MIN = d[i][h];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">1</span>;h&lt;len;h++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[h]==<span class="literal">false</span> &amp;&amp; e[u][h]!=INF)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(d[i][u]+e[u][h]&lt;d[i][h])</span><br><span class="line">                    &#123;</span><br><span class="line">                        d[i][h] = d[i][u]+e[u][h];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> aDist=INF;</span><br><span class="line">    <span class="keyword">double</span> minDis = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> dis = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> ansDis = INF;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j]&gt;ds)</span><br><span class="line">            &#123;</span><br><span class="line">                flag =<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(d[i][j]&lt;ansDis) ansDis = <span class="number">1.0</span>*d[i][j];</span><br><span class="line">            dis+=<span class="number">1.0</span>*d[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)</span><br><span class="line">        &#123;</span><br><span class="line">            dis = dis/n;</span><br><span class="line">            <span class="keyword">if</span>(ansDis &gt; minDis)</span><br><span class="line">            &#123;</span><br><span class="line">                minDis = ansDis;</span><br><span class="line">                pos = i;</span><br><span class="line">                aDist = dis;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ansDis == minDis &amp;&amp; dis&lt;aDist)</span><br><span class="line">            &#123;</span><br><span class="line">                aDist = dis;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pos==<span class="number">0</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">"No Solution"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"G%d\n%.1f %.1f"</span>,pos,minDis,aDist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1034-Head-of-a-Gang-30-图的遍历，DFS"><a href="#1034-Head-of-a-Gang-30-图的遍历，DFS" class="headerlink" title="1034. Head of a Gang (30) [图的遍历，DFS]"></a>1034. Head of a Gang (30) [图的遍历，DFS]</h1><p>测试点3段错误，28分，奇怪。。。<br>第二次回过头来重写，AC！（其间发现有一个点未过，仔细检查后发现是边权累加的问题被忽视了）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; name;</span><br><span class="line"><span class="keyword">int</span> e[maxn][maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; exist;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; point;</span><br><span class="line"><span class="keyword">int</span> t,k,lineSum,head,person,maxPoint;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vedge[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Node &amp;a,<span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.name&lt;b.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(point[name[v]]&gt;maxPoint)</span><br><span class="line">    &#123;</span><br><span class="line">        maxPoint=point[name[v]];</span><br><span class="line">        head = v;</span><br><span class="line">    &#125;</span><br><span class="line">    person++;</span><br><span class="line">    vis[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vedge[v][i]==<span class="literal">false</span> &amp;&amp; e[v][i]!=INF)</span><br><span class="line">        &#123;</span><br><span class="line">            lineSum+=e[v][i];</span><br><span class="line">            vedge[v][i]=<span class="literal">true</span>;</span><br><span class="line">            vedge[i][v]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span> &amp;&amp; e[v][i]!=INF)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">    fill(e[<span class="number">0</span>],e[<span class="number">0</span>]+maxn*maxn,INF);</span><br><span class="line">    t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> a,b;</span><br><span class="line">        <span class="keyword">int</span> le;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;le;</span><br><span class="line">        <span class="keyword">if</span>(exist.find(a) == exist.end())</span><br><span class="line">        &#123;</span><br><span class="line">            exist.insert(a);</span><br><span class="line">            pos[a]=t;</span><br><span class="line">            name[t]=a;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exist.find(b) == exist.end())</span><br><span class="line">        &#123;</span><br><span class="line">            exist.insert(b);</span><br><span class="line">            pos[b]=t;</span><br><span class="line">            name[t]=b;</span><br><span class="line">            t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(e[pos[a]][pos[b]]==INF)</span><br><span class="line">        &#123;</span><br><span class="line">            e[pos[a]][pos[b]]=le;</span><br><span class="line">            e[pos[b]][pos[a]]=le;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            e[pos[a]][pos[b]]+=le;</span><br><span class="line">            e[pos[b]][pos[a]]+=le;</span><br><span class="line">        &#125;</span><br><span class="line">        point[a]+=le;</span><br><span class="line">        point[b]+=le;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Node&gt; ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lineSum=<span class="number">0</span>;</span><br><span class="line">        maxPoint = <span class="number">-1</span>;</span><br><span class="line">        person=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lineSum&gt;k &amp;&amp; person&gt;<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(&#123;name[head],person&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans.size());</span><br><span class="line">    sort(ans.begin(),ans.end(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it:ans) <span class="built_in">printf</span>(<span class="string">"%s %d\n"</span>,it.name.c_str(),it.amount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1030-Travel-Plan-30-Dijkstra算法-DFS，最短路径，边权"><a href="#1030-Travel-Plan-30-Dijkstra算法-DFS，最短路径，边权" class="headerlink" title="1030. Travel Plan (30) [Dijkstra算法 + DFS，最短路径，边权]"></a>1030. Travel Plan (30) [Dijkstra算法 + DFS，最短路径，边权]</h1><p>很简单的题，但是很傻逼的在一开始读数据的时候就少读了一行。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> e[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> cost[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> pre[maxv];</span><br><span class="line"><span class="keyword">int</span> n,m,D,s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;D);</span><br><span class="line">    fill(e[<span class="number">0</span>],e[<span class="number">0</span>]+maxv*maxv,INF);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c1,c2,dis,<span class="built_in">cos</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;c1,&amp;c2,&amp;dis,&amp;<span class="built_in">cos</span>);</span><br><span class="line">        e[c1][c2]=e[c2][c1]=dis;</span><br><span class="line">        cost[c1][c2]=cost[c2][c1]=<span class="built_in">cos</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> c[maxv],d[maxv];</span><br><span class="line">    fill(c,c+maxv,INF);</span><br><span class="line">    fill(d,d+maxv,INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    c[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pre[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; e[u][j]!=INF)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+e[u][j]&lt;d[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[j] = d[u]+e[u][j];</span><br><span class="line">                    c[j] = c[u]+cost[u][j];</span><br><span class="line">                    pre[j] = u;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+e[u][j]==d[j] &amp;&amp; c[j] &gt; c[u]+cost[u][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[j] = c[u]+cost[u][j];</span><br><span class="line">                    pre[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(D);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,d[D],c[D]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1021-Deepest-Root-25-图的遍历，DFS，计算连通分量的个数"><a href="#1021-Deepest-Root-25-图的遍历，DFS，计算连通分量的个数" class="headerlink" title="1021. Deepest Root (25) [图的遍历，DFS，计算连通分量的个数]"></a>1021. Deepest Root (25) [图的遍历，DFS，计算连通分量的个数]</h1><p>分析：⾸先深度优先搜索判断它有⼏个连通分量。如果有多个，那就输出Error: x components，如果只有⼀个，就两次深度优先搜索，先从⼀个结点dfs后保留最⾼⾼度拥有的结点们，然后从这些结点中的其中任意⼀个开始dfs得到最⾼⾼度的结点们，这两个结点集合的并集就是所求</p>
<p>我一开始在担心是否存在有环的情况，结果发现边只有n-1条，如果是连通图，那么不可能存在环路。。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Adj[maxn];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxDepth;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth&gt;maxDepth)</span><br><span class="line">    &#123;</span><br><span class="line">        maxDepth = depth;</span><br><span class="line">        temp.clear();</span><br><span class="line">        temp.push_back(v);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(depth == maxDepth) temp.push_back(v);</span><br><span class="line">    vis[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Adj[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[Adj[v][i]]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(Adj[v][i],depth+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        Adj[a].push_back(b);</span><br><span class="line">        Adj[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s1 = <span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(i,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                s1 = temp[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> it:temp) s.insert(it);</span><br><span class="line">            &#125;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Error: %d components"</span>,cnt);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxDepth = <span class="number">0</span>;</span><br><span class="line">        fill(vis,vis+maxn,<span class="literal">false</span>);</span><br><span class="line">        temp.clear();</span><br><span class="line">        DFS(s1,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:temp) s.insert(it);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it:s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1018-Public-Bike-Management-30-Dijkstra算法-DFS-（新知识！！！）"><a href="#1018-Public-Bike-Management-30-Dijkstra算法-DFS-（新知识！！！）" class="headerlink" title="1018. Public Bike Management (30) [Dijkstra算法 + DFS]（新知识！！！）"></a>1018. Public Bike Management (30) [Dijkstra算法 + DFS]（新知识！！！）</h1><p>有两个点没过。。。25分。。。<br><strong>新的学习点：</strong><br>对于有多种判断条件的时候，先dijkstra，然后DFS遍历多条路径，针对每条已经遍历完成的路径再进行优化选取！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有两个点没通过</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> cm,n,sp,m;</span><br><span class="line"><span class="keyword">int</span> bikes[maxv];</span><br><span class="line"><span class="keyword">int</span> e[maxv][maxv];</span><br><span class="line"><span class="keyword">int</span> send = -INF,getback = INF;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[maxv];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path,fin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin.push_back(v);</span><br><span class="line">    temp+=bikes[v];</span><br><span class="line">    <span class="keyword">if</span>(v==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">0</span> &amp;&amp; temp&gt;send)</span><br><span class="line">        &#123;</span><br><span class="line">            send = temp;</span><br><span class="line">            path = fin;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(send == -INF &amp;&amp; temp&gt;<span class="number">0</span> &amp;&amp; temp&lt;getback)</span><br><span class="line">        &#123;</span><br><span class="line">            getback = temp;</span><br><span class="line">            path = fin;</span><br><span class="line">        &#125;</span><br><span class="line">        fin.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(pre[v][i],temp);</span><br><span class="line">    &#125;</span><br><span class="line">    fin.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(e[<span class="number">0</span>],e[<span class="number">0</span>]+maxv*maxv,INF);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;cm,&amp;n,&amp;sp,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;weight);</span><br><span class="line">        bikes[i]=weight-cm/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bikes[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;t);</span><br><span class="line">        e[a][b]=e[b][a]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d[maxv];</span><br><span class="line">    fill(d,d+maxv,INF);</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; e[u][j] != INF)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+e[u][j]&lt;d[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[j] = d[u]+e[u][j];</span><br><span class="line">                    pre[j].clear();</span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+e[u][j]==d[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(sp,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(send != -INF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,-send);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,path[i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" 0"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 "</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=path.size()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,path[i]);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" %d"</span>,getback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1013-Battle-Over-Cities-25-图的遍历，统计连通分量的个数，DFS"><a href="#1013-Battle-Over-Cities-25-图的遍历，统计连通分量的个数，DFS" class="headerlink" title="1013. Battle Over Cities (25) [图的遍历，统计连通分量的个数，DFS]"></a>1013. Battle Over Cities (25) [图的遍历，统计连通分量的个数，DFS]</h1><p>答案是利用vis数组，每次还存在为false的点就进行DFS，每次DFS过后连通分量的个数加1。<br>不知道为什么用邻接表法出现了段错误。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxv = <span class="number">1010</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> lost,num;</span><br><span class="line"><span class="keyword">bool</span> vis[maxv] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> e[maxv][maxv];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[v]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span> &amp;&amp; e[v][i]==<span class="number">1</span>)</span><br><span class="line">            DFS(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(i);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,cnt<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(e[<span class="number">0</span>],e[<span class="number">0</span>]+maxv*maxv,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        e[a][b]=e[b][a]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;lost);</span><br><span class="line">        fill(vis,vis+maxv,<span class="literal">false</span>);</span><br><span class="line">        vis[lost] = <span class="literal">true</span>;</span><br><span class="line">        DFSTraverse();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>根据两种遍历序列建树</title>
    <url>/2019/08/09/%E6%A0%B9%E6%8D%AE%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%BB%BA%E6%A0%91/</url>
    <content><![CDATA[<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;index, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, <span class="keyword">int</span> postLeft, <span class="keyword">int</span> postRight)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (inLeft &gt; inRight) <span class="keyword">return</span>;    </span><br><span class="line">    index = postRight;    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (in[i] != post[postRight]) i++;    </span><br><span class="line">    dfs(tree[index][<span class="number">0</span>], inLeft, i - <span class="number">1</span>, postLeft, postLeft + (i - inLeft) - <span class="number">1</span>);    dfs(tree[index][<span class="number">1</span>], i + <span class="number">1</span>, inRight, postLeft + (i - inLeft), postRight - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>树的遍历</tag>
        <tag>树的重建</tag>
      </tags>
  </entry>
  <entry>
    <title>按类刷题系列总结1</title>
    <url>/2019/07/29/%E6%8C%89%E7%B1%BB%E5%88%B7%E9%A2%98%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%931/</url>
    <content><![CDATA[<h1 id="1155-Heap-Paths-30-深搜回溯，堆"><a href="#1155-Heap-Paths-30-深搜回溯，堆" class="headerlink" title="1155. Heap Paths (30) [深搜回溯，堆]"></a>1155. Heap Paths (30) [深搜回溯，堆]</h1><p>第二次重做，问题出在大小根堆的判断上，我是通过遍历出来的序列看它是否是从小到大或从大到小来判断的，而这种办法在第三个测试点上无法通过，正确判定方法应为：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>  isMin = <span class="number">1</span>, isMax = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[i/<span class="number">2</span>] &gt; tree[i]) isMin = <span class="number">0</span>; <span class="comment">//i/2即是找父节点</span></span><br><span class="line">    <span class="keyword">if</span> (tree[i/<span class="number">2</span>] &lt; tree[i]) isMax = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isMin == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Min Heap"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, isMax == <span class="number">1</span> ? <span class="string">"Max Heap"</span> : <span class="string">"Not Heap"</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">bool</span> isMirror;</span><br><span class="line"><span class="keyword">int</span> flag,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*v &gt; n &amp;&amp; <span class="number">2</span>*v+<span class="number">1</span> &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(v&lt;=n)</span><br><span class="line">        &#123;</span><br><span class="line">            temp.push_back(tree[v]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,temp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            temp.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.push_back(tree[v]);</span><br><span class="line">    DFS(<span class="number">2</span>*v+<span class="number">1</span>);</span><br><span class="line">    DFS(<span class="number">2</span>*v);</span><br><span class="line">    temp.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    tree.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[i]);</span><br><span class="line">    DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span>  isMin = <span class="number">1</span>, isMax = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tree[i/<span class="number">2</span>] &gt; tree[i]) isMin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree[i/<span class="number">2</span>] &lt; tree[i]) isMax = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isMin == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Min Heap"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, isMax == <span class="number">1</span> ? <span class="string">"Max Heap"</span> : <span class="string">"Not Heap"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>循环中判断最后是否输出空格有更简洁的方法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d%s"</span>, v[i], i != v.size() - <span class="number">1</span> ? <span class="string">" "</span> : <span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对DFS和二叉树遍历的认识不够深刻。</p>
<h1 id="1151-LCA-in-a-Binary-Tree-30-树的遍历，中序前序建树，LCA算法"><a href="#1151-LCA-in-a-Binary-Tree-30-树的遍历，中序前序建树，LCA算法" class="headerlink" title="1151. LCA in a Binary Tree (30) [树的遍历，中序前序建树，LCA算法]"></a>1151. LCA in a Binary Tree (30) [树的遍历，中序前序建树，LCA算法]</h1><p>在做这题的时候，我原本的想法是用数组根据先序和中序序列建树处理，但是题目中所给的元素并没有明确的规定，所以使用数组进行建树的结点对应问题无法解决。（同时自己对建树也不熟练）<br>最后自己还是没写出来，参考柳神的题解，她的做法非常屌，不需要建树（但是我还是要学一下怎么建树）：</p>
</li>
<li>设置了一个map，用来给每个inorder序列中的元素设置其对应的inorder序列的位置。好处是在后续判断树的结点中是否含有题给元素时可以直接在map中查询判断。（<strong><em>此法可以在其他题目中学以致用</em></strong>）</li>
<li><p>已知某个树的根结点，若a和b在根结点的左边，则a和b的近公共祖先在当前⼦子树根结点的左⼦子树寻找，如果a和b在当前⼦子树根结点的两边，在当前⼦子树的根结点就是a和b的近公共祖先，如果a和b在当前⼦子树根结点的右边，则a和b的近公共祖先就在当前⼦子树的右⼦子树寻找。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> inl, <span class="keyword">int</span> inr, <span class="keyword">int</span> preRoot, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (inl &gt; inr) <span class="keyword">return</span>;    </span><br><span class="line">    <span class="keyword">int</span> inRoot = pos[pre[preRoot]], aIn = pos[a], bIn = pos[b]; </span><br><span class="line">    <span class="keyword">if</span> (aIn &lt; inRoot &amp;&amp; bIn &lt; inRoot)</span><br><span class="line">        lca(inl, inRoot<span class="number">-1</span>, preRoot+<span class="number">1</span>, a, b);    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((aIn &lt; inRoot &amp;&amp; bIn &gt; inRoot) || </span><br><span class="line">            (aIn &gt; inRoot &amp;&amp; bIn &lt; inRoot))    </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>, a, b, in[inRoot]);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aIn &gt; inRoot &amp;&amp; bIn &gt; inRoot)        </span><br><span class="line">        lca(inRoot+<span class="number">1</span>, inr, preRoot+<span class="number">1</span>+(inRoot-inl), a, b);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (aIn == inRoot)            </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, a, b);    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bIn == inRoot)            </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>, b, a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一个新学的小技巧，使用vector，可以在获取到元素数目后，使用resize(n)为其设置大小操作。（<strong><em>此法可以在其他题目中学以致用</em></strong>）</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下是我模仿柳神写的代码。。。</span></span><br><span class="line"><span class="comment">//需要注意的是：PAT的OJ是可以读一句输出一句的，不用等所有读完再输出。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder,preorder;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> inL,<span class="keyword">int</span> inR,<span class="keyword">int</span> preRoot,<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inRoot = pos[preorder[preRoot]];</span><br><span class="line">    <span class="keyword">if</span>(pos[a]&lt;inRoot &amp;&amp; pos[b]&lt;inRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        lca(inL,inRoot<span class="number">-1</span>,preRoot+<span class="number">1</span>,a,b);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((pos[a]&lt;inRoot &amp;&amp; pos[b]&gt;inRoot) ||</span><br><span class="line">            (pos[a]&gt;inRoot &amp;&amp; pos[b]&lt;inRoot))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LCA of %d and %d is %d.\n"</span>,a,b,inorder[inRoot]);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos[a]&gt;inRoot &amp;&amp; pos[b]&gt;inRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        lca(inRoot+<span class="number">1</span>,inR,preRoot+<span class="number">1</span>+inRoot-inL,a,b);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos[a]==inRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>,a,b);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos[b]==inRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d is an ancestor of %d.\n"</span>,b,a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    inorder.resize(n+<span class="number">1</span>);</span><br><span class="line">    preorder.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;inorder[i]);</span><br><span class="line">        pos[inorder[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;preorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(pos[a]==<span class="number">0</span> &amp;&amp; pos[b]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d and %d are not found.\n"</span>,a,b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos[a]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>,a);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pos[b]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"ERROR: %d is not found.\n"</span>,b);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lca(<span class="number">1</span>,n,<span class="number">1</span>,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="1147-Heaps-30-堆，树的遍历"><a href="#1147-Heaps-30-堆，树的遍历" class="headerlink" title="1147. Heaps (30) [堆，树的遍历]"></a>1147. Heaps (30) [堆，树的遍历]</h1><p>涉及到完全二叉树的层次遍历的性质，注意其层次遍历的结点中含有子节点的结点个数为n/2个，所以本题在判断是否是堆的时候知道这个性质后能够极大地简化代码。<br>另外，大根堆还是小根堆可以通过层次序列的前两个数的比较就能做出初步的判断。<br>（我的静态数组形式二叉树的后序遍历居然不熟练！！！）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(<span class="number">2</span>*root);</span><br><span class="line">    postOrder(<span class="number">2</span>*root+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%s"</span>,tree[root],root==<span class="number">1</span>?<span class="string">"\n"</span>:<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">    tree.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = tree[<span class="number">1</span>]&gt;=tree[<span class="number">2</span>]?<span class="number">1</span>:<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n/<span class="number">2</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span> &amp;&amp; (tree[<span class="number">2</span>*j]&gt;tree[j] ||(<span class="number">2</span>*j+<span class="number">1</span> &lt; n &amp;&amp; tree[<span class="number">2</span>*j+<span class="number">1</span>]&gt;tree[j])))&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span> &amp;&amp; (tree[<span class="number">2</span>*j]&lt;tree[j] || (<span class="number">2</span>*j+<span class="number">1</span> &lt; n &amp;&amp; tree[<span class="number">2</span>*j+<span class="number">1</span>]&lt;tree[j])))&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Max Heap\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(flag == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Min Heap\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"Not Heap\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        postOrder(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1138-Postorder-Traversal-25-树的遍历，前序中序转后序"><a href="#1138-Postorder-Traversal-25-树的遍历，前序中序转后序" class="headerlink" title="1138. Postorder Traversal (25) [树的遍历，前序中序转后序]"></a>1138. Postorder Traversal (25) [树的遍历，前序中序转后序]</h1><p>直接求了后序序列，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,in,post;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> pl,<span class="keyword">int</span> pr,<span class="keyword">int</span> il,<span class="keyword">int</span> ir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(il&gt;ir) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i=il;</span><br><span class="line">    <span class="keyword">while</span>(in[i]!=pre[pl]) i++;</span><br><span class="line">    postOrder(pl+<span class="number">1</span>,pl+i-il,il,i<span class="number">-1</span>);</span><br><span class="line">    postOrder(pl+i-il+<span class="number">1</span>, pr, i+<span class="number">1</span>,ir);</span><br><span class="line">    post.push_back(in[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    pre.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;pre[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i]);</span><br><span class="line">    postOrder(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,post[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1135-Is-It-A-Red-Black-Tree-30-红⿊黑树"><a href="#1135-Is-It-A-Red-Black-Tree-30-红⿊黑树" class="headerlink" title="1135. Is It A Red-Black Tree (30) [红⿊黑树]"></a>1135. Is It A Red-Black Tree (30) [红⿊黑树]</h1><p>首先，很惭愧，题目都没看懂，原因是：</p>
<ol>
<li>没看到这句话：<code>For each given binary search tree,</code></li>
<li>没看懂这句话：<code>(3) Every leaf (NULL) is black.</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge1</span><span class="params">(node *root)</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; <span class="number">0</span>) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;left-&gt;val &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span> &amp;&amp; root-&gt;right-&gt;val &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> judge1(root-&gt;left) &amp;&amp; judge1(root-&gt;right); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNum</span><span class="params">(node *root)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">int</span> l = getNum(root-&gt;left);    </span><br><span class="line">    <span class="keyword">int</span> r = getNum(root-&gt;right);    </span><br><span class="line">    <span class="keyword">return</span> root-&gt;val &gt; <span class="number">0</span> ? max(l, r) + <span class="number">1</span> : max(l, r);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge2</span><span class="params">(node *root)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;    </span><br><span class="line">    <span class="keyword">int</span> l = getNum(root-&gt;left);    </span><br><span class="line">    <span class="keyword">int</span> r = getNum(root-&gt;right);    </span><br><span class="line">    <span class="keyword">if</span>(l != r) <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    <span class="keyword">return</span> judge2(root-&gt;left) &amp;&amp; judge2(root-&gt;right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1131-Subway-Map-30-dfs深度优先搜索"><a href="#1131-Subway-Map-30-dfs深度优先搜索" class="headerlink" title="1131. Subway Map (30) [dfs深度优先搜索]"></a>1131. Subway Map (30) [dfs深度优先搜索]</h1><h1 id="1130-Infix-Expression-25-dfs深度优先搜索"><a href="#1130-Infix-Expression-25-dfs深度优先搜索" class="headerlink" title="1130. Infix Expression (25) [dfs深度优先搜索]"></a>1130. Infix Expression (25) [dfs深度优先搜索]</h1><p>后序遍历的小变形，AC！（终于/(ㄒoㄒ)/~~）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">100</span>] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r!= root &amp;&amp; (tree[r].left != <span class="number">-1</span> || tree[r].right != <span class="number">-1</span>)) <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">    postOrder(tree[r].left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,tree[r].data);</span><br><span class="line">    postOrder(tree[r].right);</span><br><span class="line">    <span class="keyword">if</span>(r!=root &amp;&amp; (tree[r].left != <span class="number">-1</span> || tree[r].right != <span class="number">-1</span>)) <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    tree.resize(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d %d"</span>,&amp;tree[i].data,&amp;tree[i].left,&amp;tree[i].right);</span><br><span class="line">        <span class="keyword">if</span>(tree[i].left != <span class="number">-1</span>) vis[tree[i].left] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(tree[i].right != <span class="number">-1</span>) vis[tree[i].right] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1127-ZigZagging-on-a-Tree-30-中序后序建树，层序遍历"><a href="#1127-ZigZagging-on-a-Tree-30-中序后序建树，层序遍历" class="headerlink" title="1127. ZigZagging on a Tree (30) [中序后序建树，层序遍历]"></a>1127. ZigZagging on a Tree (30) [中序后序建树，层序遍历]</h1><p>对于不熟练的我来说好难啊。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> &amp;index, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, <span class="keyword">int</span> postLeft, <span class="keyword">int</span> postRight)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (inLeft &gt; inRight) <span class="keyword">return</span>;    </span><br><span class="line">    index = postRight;    </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span> (in[i] != post[postRight]) i++;    </span><br><span class="line">    dfs(tree[index][<span class="number">0</span>], inLeft, i - <span class="number">1</span>, postLeft, postLeft + (i - inLeft) - <span class="number">1</span>);    dfs(tree[index][<span class="number">1</span>], i + <span class="number">1</span>, inRight, postLeft + (i - inLeft), postRight - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,depth;</span><br><span class="line">    Node *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; post;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; in;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pos;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node*&gt; result[<span class="number">36</span>];</span><br><span class="line">Node *root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(Node *&amp;root,<span class="keyword">int</span> inLeft,<span class="keyword">int</span> inRight,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> postLeft,<span class="keyword">int</span> postRight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inLeft&gt;inRight) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> index = post[postRight];</span><br><span class="line">    root = <span class="keyword">new</span> Node();</span><br><span class="line">    root-&gt;data = index;</span><br><span class="line">    <span class="keyword">int</span> inRoot = pos[index];</span><br><span class="line">    build(root-&gt;left, inLeft, inRoot<span class="number">-1</span>, postLeft, postLeft+inRoot-inLeft<span class="number">-1</span>);</span><br><span class="line">    build(root-&gt;right, inRoot+<span class="number">1</span>, inRight, postLeft+inRoot-inLeft, postRight<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    root-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        result[temp-&gt;depth].push_back(temp);</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;left-&gt;depth=temp-&gt;depth+<span class="number">1</span>;</span><br><span class="line">            q.push(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;right-&gt;depth=temp-&gt;depth+<span class="number">1</span>;</span><br><span class="line">            q.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result[<span class="number">1</span>][<span class="number">0</span>]-&gt;data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">36</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;result[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,result[i][j]-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=result[i].size()<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" %d"</span>,result[i][j]-&gt;data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    post.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i]);</span><br><span class="line">        pos[in[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;post[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    build(root,<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    BFS(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1119-Pre-and-Post-order-Traversals-30-树的遍历，前序后序转中序"><a href="#1119-Pre-and-Post-order-Traversals-30-树的遍历，前序后序转中序" class="headerlink" title="1119. Pre- and Post-order Traversals (30) [树的遍历，前序后序转中序]"></a>1119. Pre- and Post-order Traversals (30) [树的遍历，前序后序转中序]</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没做出来，前序，后序转中序的关键代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getIn</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> postLeft, <span class="keyword">int</span> postRight)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(preLeft == preRight) &#123;        </span><br><span class="line">        in.push_back(pre[preLeft]);        </span><br><span class="line">        <span class="keyword">return</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (pre[preLeft] == post[postRight]) &#123;        </span><br><span class="line">        <span class="keyword">int</span> i = preLeft + <span class="number">1</span>;        </span><br><span class="line">        <span class="keyword">while</span> (i &lt;= preRight &amp;&amp; pre[i] != post[postRight<span class="number">-1</span>]) i++;        </span><br><span class="line">        <span class="keyword">if</span> (i - preLeft &gt; <span class="number">1</span>)   getIn(preLeft + <span class="number">1</span>, i - <span class="number">1</span>, postLeft, postLeft + (i - preLeft - <span class="number">1</span>) - <span class="number">1</span>);     </span><br><span class="line">        <span class="keyword">else</span>            </span><br><span class="line">            unique = <span class="literal">false</span>;        </span><br><span class="line">        in.push_back(post[postRight]);        </span><br><span class="line">        getIn(i, preRight, postLeft + (i - preLeft - <span class="number">1</span>), postRight - <span class="number">1</span>);    </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1115-Counting-Nodes-in-a-BST-30-二叉树的遍历，DFS"><a href="#1115-Counting-Nodes-in-a-BST-30-二叉树的遍历，DFS" class="headerlink" title="1115. Counting Nodes in a BST (30) [二叉树的遍历，DFS]"></a>1115. Counting Nodes in a BST (30) [二叉树的遍历，DFS]</h1><p>我自己写出来了！虽然用的是BFS，而且空间复杂度有点高，但是AC了！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//我的代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,depth;</span><br><span class="line">    Node *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">R</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,depth;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *root;</span><br><span class="line"><span class="built_in">vector</span>&lt;R&gt; result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(Node *&amp;root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *temp = <span class="keyword">new</span> Node();</span><br><span class="line">    temp-&gt;data = v;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = temp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp-&gt;data&lt;=root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        build(root-&gt;left, v);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        build(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node*&gt; q;</span><br><span class="line">    root-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        R tempR;</span><br><span class="line">        tempR.data = temp-&gt;data;</span><br><span class="line">        tempR.depth = temp-&gt;depth;</span><br><span class="line">        result.push_back(tempR);</span><br><span class="line">        maxDepth = temp-&gt;depth;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;left-&gt;depth = temp-&gt;depth+<span class="number">1</span>;</span><br><span class="line">            q.push(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            temp-&gt;right-&gt;depth = temp-&gt;depth+<span class="number">1</span>;</span><br><span class="line">            q.push(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        build(root,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxDepth = BFS(root);</span><br><span class="line">    <span class="keyword">int</span> n1=<span class="number">0</span>,n2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(result[i].depth == maxDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            n1++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result[i].depth == maxDepth<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d"</span>,n1,n2,n1+n2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参考答案后改进的DFS解决代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *left,*right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node *root;</span><br><span class="line"><span class="keyword">int</span> maxDepth=<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">build</span><span class="params">(Node *root,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> Node();</span><br><span class="line">        root-&gt;data = v;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v&lt;=root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = build(root-&gt;left, v);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        root-&gt;right = build(root-&gt;right,v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Node *root, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxDepth = max(depth,maxDepth);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num[depth]++;</span><br><span class="line">    DFS(root-&gt;left, depth+<span class="number">1</span>);</span><br><span class="line">    DFS(root-&gt;right, depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        root = build(root,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(root,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d + %d = %d"</span>,num[maxDepth<span class="number">-1</span>],num[maxDepth<span class="number">-2</span>],num[maxDepth<span class="number">-1</span>]+num[maxDepth<span class="number">-2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1110-Complete-Binary-Tree-25-完全二叉树"><a href="#1110-Complete-Binary-Tree-25-完全二叉树" class="headerlink" title="1110. Complete Binary Tree (25) [完全二叉树]"></a>1110. Complete Binary Tree (25) [完全二叉树]</h1><p>分析：递归出最大的下标值，完全二叉树一定把前⾯面的下标充满： 最大的下标值 == 最大的节点数； 不完全二叉树前面一定有位置是空，会往后挤： 最大的下标值 &gt; 最大的节点数～<br>总结：输在了解法上/(ㄒoㄒ)/~~没想到上述的做法，结果用了最朴实最繁琐的做法。</p>
<h1 id="1106-Lowest-Price-in-Supply-Chain-25-DFS，BFS，树的遍历"><a href="#1106-Lowest-Price-in-Supply-Chain-25-DFS，BFS，树的遍历" class="headerlink" title="1106. Lowest Price in Supply Chain (25) [DFS，BFS，树的遍历]"></a>1106. Lowest Price in Supply Chain (25) [DFS，BFS，树的遍历]</h1><p>20分钟写出来拿了20分，有两个点没通过，错误点是：<br>对于结果cn应该是在minDepth&lt;depth时重置为1，当minDepth==depth时进行cn++的操作；<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> minDepth=<span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">int</span> cn = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; supply;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(supply[root].son.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth&lt;minDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            minDepth = depth;</span><br><span class="line">            cn=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(minDepth == depth)</span><br><span class="line">        &#123;</span><br><span class="line">            cn++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;supply[root].son.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(supply[root].son[i],depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> p,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf %lf"</span>,&amp;n,&amp;p,&amp;r);</span><br><span class="line">    supply.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            supply[i].son.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> result=p*<span class="built_in">pow</span>(<span class="number">1</span>+r*<span class="number">0.01</span>,minDepth);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.4f %d"</span>,result,cn);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1103-Integer-Factorization-30-深度优先搜索DFS"><a href="#1103-Integer-Factorization-30-深度优先搜索DFS" class="headerlink" title="1103. Integer Factorization (30) [深度优先搜索DFS]"></a>1103. Integer Factorization (30) [深度优先搜索DFS]</h1><p>这块关键代码理解不深！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> tempSum, <span class="keyword">int</span> tempK, <span class="keyword">int</span> facSum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tempK == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSum == n &amp;&amp; facSum &gt; maxFacSum) &#123;</span><br><span class="line">            ans = tempAns;</span><br><span class="line">            maxFacSum = facSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tempSum + v[index] &lt;= n) &#123;</span><br><span class="line">            tempAns[tempK] = index;</span><br><span class="line">            dfs(index, tempSum + v[index], tempK + <span class="number">1</span>, facSum + index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">        index--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1102-Invert-a-Binary-Tree-25-分"><a href="#1102-Invert-a-Binary-Tree-25-分" class="headerlink" title="1102 Invert a Binary Tree (25 分)"></a>1102 Invert a Binary Tree (25 分)</h1><p>一开始以为特别简单，只要输出层次和中序遍历序列就行，后来没ac，仔细看题才发现要输出的是invert的树的层次和中序，处理方法是读的时候把左右子树对调即可。</p>
<h1 id="1099-Build-A-Binary-Search-Tree-30-⼆叉查找树BST"><a href="#1099-Build-A-Binary-Search-Tree-30-⼆叉查找树BST" class="headerlink" title="1099. Build A Binary Search Tree (30) [⼆叉查找树BST]"></a>1099. Build A Binary Search Tree (30) [⼆叉查找树BST]</h1><p>自己AC的！有思路了做起来就很简单，我用的是先建树，但是data值不赋值，然后理由二叉查找树的性质，进行中序遍历，同时把从小到大排序后的序列依次赋值给遍历出来的点的data值。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> left,right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; put;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(tree[v].left,i);</span><br><span class="line">    tree[v].data = put[i];</span><br><span class="line">    i++;</span><br><span class="line">    inOrder(tree[v].right,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,tree[temp].data);</span><br><span class="line">        <span class="keyword">if</span>(tree[temp].left != <span class="number">-1</span>) q.push(tree[temp].left);</span><br><span class="line">        <span class="keyword">if</span>(tree[temp].right != <span class="number">-1</span>) q.push(tree[temp].right);</span><br><span class="line">        <span class="keyword">if</span>(!q.empty()) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    tree.resize(n);</span><br><span class="line">    put.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;tree[i].left,&amp;tree[i].right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;put[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(put.begin(),put.end());</span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    inOrder(<span class="number">0</span>,i);</span><br><span class="line">    BFS();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1094-The-Largest-Generation-25-BFS，DFS，树的遍历"><a href="#1094-The-Largest-Generation-25-BFS，DFS，树的遍历" class="headerlink" title="1094. The Largest Generation (25) [BFS，DFS，树的遍历]"></a>1094. The Largest Generation (25) [BFS，DFS，树的遍历]</h1><p>就是BFS和DFS的深度问题，没有一次通过，需要注意的是只有一个结点时，和最大代数在最后一层时的数据更新问题。最后自己AC了！<br>柳神的代码没有采用BFS，而是设置了一个用来记录每层结点个数的数组（这个想法好屌！），故一次DFS之后，直接遍历一遍记录每层结点个数的数组，找到最大值和索引号输出即可！</p>
<h1 id="1091-Acute-Stroke-30-⼴度优先搜索BFS-（三维处理典型例题）"><a href="#1091-Acute-Stroke-30-⼴度优先搜索BFS-（三维处理典型例题）" class="headerlink" title="1091. Acute Stroke (30) [⼴度优先搜索BFS]（三维处理典型例题）"></a>1091. Acute Stroke (30) [⼴度优先搜索BFS]（<em>三维处理典型例题</em>）</h1><p>首先题意没有理解。。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">1300</span>][<span class="number">130</span>][<span class="number">65</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1300</span>][<span class="number">130</span>][<span class="number">65</span>];</span><br><span class="line"><span class="keyword">int</span> m,n,l,t;</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Z[<span class="number">6</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=m || y&lt;<span class="number">0</span> || y&gt;=n || z&lt;<span class="number">0</span> || z&gt;= l) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(vis[x][y][z]==<span class="literal">true</span> || matrix[x][y][z] == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算每个点向外三维延申相连接的所有1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    Node f;</span><br><span class="line">    f.x=x,f.y=y,f.z=z;</span><br><span class="line">    q.push(f);</span><br><span class="line">    vis[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node temp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = temp.x+X[i];</span><br><span class="line">            <span class="keyword">int</span> ty = temp.y+Y[i];</span><br><span class="line">            <span class="keyword">int</span> tz = temp.z+Z[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(tx,ty,tz))</span><br><span class="line">            &#123;</span><br><span class="line">                vis[tx][ty][tz] = <span class="literal">true</span>;</span><br><span class="line">                Node newN;</span><br><span class="line">                newN.x=tx,newN.y=ty,newN.z=tz;</span><br><span class="line">                q.push(newN);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt&gt;=t) <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;m,&amp;n,&amp;l,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;matrix[j][k][i]);</span><br><span class="line">                vis[j][k][i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//需要注意，必须只对未访问过和为1的进行累加</span></span><br><span class="line">                <span class="keyword">if</span>(vis[j][k][i]==<span class="literal">false</span> &amp;&amp; matrix[j][k][i] == <span class="number">1</span>)</span><br><span class="line">                    result += BFS(j,k,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1090-Highest-Price-in-Supply-Chain-25-树的遍历"><a href="#1090-Highest-Price-in-Supply-Chain-25-树的遍历" class="headerlink" title="1090. Highest Price in Supply Chain (25) [树的遍历]"></a>1090. Highest Price in Supply Chain (25) [树的遍历]</h1><p>很简单的一个DFS，出了个赋值上的小bug，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">100010</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree[INF];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> p,r;</span><br><span class="line"><span class="keyword">int</span> maxDepth=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[v].empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth &gt; maxDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(depth == maxDepth)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(tree[v][i],depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%lf%lf"</span>,&amp;n,&amp;p,&amp;r);</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp != <span class="number">-1</span>) tree[temp].push_back(i);</span><br><span class="line">        <span class="keyword">else</span> root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> sell = p*<span class="built_in">pow</span>(<span class="number">1</span>+r*<span class="number">0.01</span>,maxDepth);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f %d"</span>,sell,cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1086-Tree-Traversals-Again-25-树的遍历"><a href="#1086-Tree-Traversals-Again-25-树的遍历" class="headerlink" title="1086. Tree Traversals Again (25) [树的遍历]"></a>1086. Tree Traversals Again (25) [树的遍历]</h1><p>注意！栈实现的是⼆叉树的中序遍历（左根右），⽽每次push⼊值的顺序是⼆叉树的前序遍历（根左右），所以该题可以⽤⼆叉树前序和中序转后序的⽅法做～<br>前序中序转后序还是不熟练!!!<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> push = <span class="string">"Push"</span>;</span><br><span class="line"><span class="built_in">string</span> pop = <span class="string">"Pop"</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; post,in,pre;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; inS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> endd,<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;endd) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;endd &amp;&amp; in[i] != pre[root]) i++;</span><br><span class="line">    postOrder(start, i<span class="number">-1</span>, root+<span class="number">1</span>);</span><br><span class="line">    postOrder(i+<span class="number">1</span>, endd, root+i-start+<span class="number">1</span>);</span><br><span class="line">    post.push_back(pre[root]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> temps;</span><br><span class="line">    <span class="keyword">int</span> tempi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;temps;</span><br><span class="line">        <span class="keyword">if</span>(temps == push)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;tempi;</span><br><span class="line">            inS.push(tempi);</span><br><span class="line">            pre.push_back(tempi);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            in.push_back(inS.top());</span><br><span class="line">            inS.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(<span class="number">0</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;post.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;post[i];</span><br><span class="line">        <span class="keyword">if</span>(i!=post.size()<span class="number">-1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1079-Total-Sales-of-Supply-Chain-25-DFS，BFS，树的遍历"><a href="#1079-Total-Sales-of-Supply-Chain-25-DFS，BFS，树的遍历" class="headerlink" title="1079. Total Sales of Supply Chain (25) [DFS，BFS，树的遍历]"></a>1079. Total Sales of Supply Chain (25) [DFS，BFS，树的遍历]</h1><p>简单的DFS处理，AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> mount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> p,r;</span><br><span class="line"><span class="keyword">double</span> result=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tree[v].children.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        result += p*<span class="built_in">pow</span>(<span class="number">1</span>+r*<span class="number">0.01</span>,depth)*tree[v].mount;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[v].children.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(tree[v].children[i],depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf %lf"</span>,&amp;n,&amp;p,&amp;r);</span><br><span class="line">    tree.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[i].mount);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tree[i].mount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                tree[i].children.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1064-Complete-Binary-Search-Tree-30-⼆叉查找树BST"><a href="#1064-Complete-Binary-Search-Tree-30-⼆叉查找树BST" class="headerlink" title="1064. Complete Binary Search Tree (30) [⼆叉查找树BST]"></a>1064. Complete Binary Search Tree (30) [⼆叉查找树BST]</h1><p>一开始被吓到了，以为要用AVL，后来仔细想了想完全二叉树和BST的性质，BST的中序遍历序列为从小到大的有序序列，而给定结点数量完全二叉树就定型了，于是直接对tree数组当作完全二叉树进行中序遍历，并把从小到大排列好的有序序列依次在遍历中赋值给tree的结点，然后将tree从头到尾输出就是层序遍历的结果！最后AC！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getT;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v&gt;n &amp;&amp; v+<span class="number">1</span>&gt;n) <span class="keyword">return</span>;</span><br><span class="line">    DFS(<span class="number">2</span>*v);</span><br><span class="line">    tree[v] = getT[temp];</span><br><span class="line">    temp++;</span><br><span class="line">    DFS(<span class="number">2</span>*v+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    tree.resize(n+<span class="number">1</span>);</span><br><span class="line">    getT.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;getT[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(getT.begin(),getT.end());</span><br><span class="line">    DFS(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,tree[i]);</span><br><span class="line">        <span class="keyword">if</span>(i!=n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1053-Path-of-Equal-Weight-30-分-树的遍历"><a href="#1053-Path-of-Equal-Weight-30-分-树的遍历" class="headerlink" title="1053 Path of Equal Weight (30 分)[树的遍历]"></a>1053 Path of Equal Weight (30 分)[树的遍历]</h1><p>一开始采用的方法是先把所有的符合要求的序列求出来，然后存入一个vector中，对vector里的所有序列按从大到小排好序之后再输出。但是这种做法导致测试点2答案错误，原因未知。<br>后来换了个方法，直接在每次获取孩子结点集合<code>vector&lt;int&gt; children</code>后对其中的孩子结点按weight值从大到小排列，这样在进行DFS时可以每成功获取一个序列就直接输出，结果也是从大到小排列的序列集，这种做法AC了。。。。。。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; children;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; tree;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">long</span> <span class="keyword">long</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum+=tree[v].weight;</span><br><span class="line">    temp.push_back(tree[v].weight);</span><br><span class="line">    <span class="keyword">if</span>(tree[v].children.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;temp.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d%s"</span>,temp[i],i==temp.size()<span class="number">-1</span>?<span class="string">"\n"</span>:<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tree[v].children.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(tree[v].children[i],sum);</span><br><span class="line">        temp.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[v1].weight&gt;tree[v2].weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %lld"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    tree.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;tree[i].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> id,k,ids;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;id,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ids);</span><br><span class="line">            tree[id].children.push_back(ids);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(tree[id].children.begin(),tree[id].children.end(),cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1043-Is-It-a-Binary-Search-Tree-25-⼆叉查找树BST"><a href="#1043-Is-It-a-Binary-Search-Tree-25-⼆叉查找树BST" class="headerlink" title="1043. Is It a Binary Search Tree (25) [⼆叉查找树BST]"></a>1043. Is It a Binary Search Tree (25) [⼆叉查找树BST]</h1><p>原来的做法出问题了，前序中序转后序的模板需要满足每个结点的值都不一样，而本题存在结点值一样的情况。。。</p>
<p>分析：假设它是⼆叉搜索树，⼀开始isMirror为FALSE，<strong>根据⼆叉搜索树的性质将已知的前序转换为后序</strong>，转换过程中，如果发现最后输出的后序数组⻓度不为n，那就设isMirror为true，然后清空后序数组，重新再转换⼀次（根据镜⾯⼆叉搜索树的性质），如果依旧转换后数组⼤⼩不等于n，就输出no，否则输出yes</p>
<h2 id="根据⼆叉搜索树的性质将已知的前序转换为后序的方法"><a href="#根据⼆叉搜索树的性质将已知的前序转换为后序的方法" class="headerlink" title="根据⼆叉搜索树的性质将已知的前序转换为后序的方法"></a>根据⼆叉搜索树的性质将已知的前序转换为后序的方法</h2><p>本质上是前序中序转后序方法的变形，只不过在BST中，前序包含了中序的作用，直接跳过了中序可以得到需要的信息。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getpost</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root &gt; tail) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">int</span> i = root + <span class="number">1</span>, j = tail;</span><br><span class="line">    <span class="keyword">if</span>(!isMirror) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= tail &amp;&amp; pre[root] &gt; pre[i]) i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; root &amp;&amp; pre[root] &lt;= pre[j]) j--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= tail &amp;&amp; pre[root] &lt;= pre[i]) i++;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; root &amp;&amp; pre[root] &gt; pre[j]) j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i - j != <span class="number">1</span>) <span class="keyword">return</span> ;</span><br><span class="line">    getpost(root + <span class="number">1</span>, j);</span><br><span class="line">    getpost(i, tail);</span><br><span class="line">    post.push_back(pre[root]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1020-Tree-Traversals-25-分-⼆叉树的遍历，后序中序转层序"><a href="#1020-Tree-Traversals-25-分-⼆叉树的遍历，后序中序转层序" class="headerlink" title="1020 Tree Traversals (25 分)[⼆叉树的遍历，后序中序转层序]"></a>1020 Tree Traversals (25 分)[⼆叉树的遍历，后序中序转层序]</h1><p>哈哈哈，用了之前新学的一个知识处理的，AC！设置了一个level数组，用来在先序遍历的过程中按层push进去，之后只要按顺序遍历level数组输出就行了！<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level[<span class="number">30</span>],post,in;</span><br><span class="line"><span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> endd,<span class="keyword">int</span> root,<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;endd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(depth&gt;maxDepth)</span><br><span class="line">            maxDepth = depth;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n &amp;&amp; post[root]!= in[i]) i++;</span><br><span class="line">    level[depth].push_back(post[root]);</span><br><span class="line">    levelOrder(start,i<span class="number">-1</span>,root-endd+i<span class="number">-1</span>,depth+<span class="number">1</span>);</span><br><span class="line">    levelOrder(i+<span class="number">1</span>,endd,root<span class="number">-1</span>,depth+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    post.resize(n);</span><br><span class="line">    in.resize(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;post[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    levelOrder(<span class="number">0</span>,n<span class="number">-1</span>,n<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxDepth;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;level[i].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d%s"</span>,level[i][j],j==level[i].size()<span class="number">-1</span>?<span class="string">""</span>:<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i!=maxDepth<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>树的遍历</tag>
        <tag>DFS</tag>
        <tag>堆</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>c++ STL系列补充</title>
    <url>/2019/07/28/c-STL%E7%B3%BB%E5%88%97%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>//摘抄自柳神的《从放弃C语言到使用C++刷算法的简明教程》</p>
<p>容器中的方法rbegin（）指向的是最后一个元素。rend（）指向第一个元素前面的位置。</p>
<h1 id="C-STL之动态数组vector的使⽤"><a href="#C-STL之动态数组vector的使⽤" class="headerlink" title="C++ STL之动态数组vector的使⽤"></a>C++ STL之动态数组vector的使⽤</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>); <span class="comment">// 直接定义⻓度为10的int数组，默认这10个元素值都为0</span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">v1.resize(<span class="number">8</span>); <span class="comment">//先定义⼀个vector变量v1，然后将⻓度resize为8，默认这8个元素都是0</span></span><br><span class="line"><span class="comment">// 在定义的时候就可以对vector变量进⾏初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3(<span class="number">100</span>, <span class="number">9</span>);<span class="comment">// 把100⻓度的数组中所有的值都初始化为9</span></span><br></pre></td></tr></table></figure>
<h1 id="C-STL之unordered-map和unordered-set的使⽤"><a href="#C-STL之unordered-map和unordered-set的使⽤" class="headerlink" title="C++ STL之unordered_map和unordered_set的使⽤"></a>C++ STL之unordered_map和unordered_set的使⽤</h1><p>unordered_map在头⽂件 <code>#include &lt;unordered_map&gt;</code> 中，unordered_set在头⽂件 <code>#include&lt;unordered_set&gt;</code> 中～<br>unordered_map和map（或者unordered_set和set）的区别是，map会按照键值对的键key进⾏排序（set⾥⾯会按照集合中的元素⼤⼩进⾏排序，从⼩到⼤顺序），⽽unordered_map（或者unordered_set）省去了这个排序的过程，如果偶尔刷题时候⽤map或者set超时了，可以考虑⽤unordered_map（或者unordered_set）缩短代码运⾏时间、提⾼代码效率～⾄于⽤法和map、set是⼀样的～</p>
<h1 id="关于cctype头⽂件⾥的⼀些函数"><a href="#关于cctype头⽂件⾥的⼀些函数" class="headerlink" title="关于cctype头⽂件⾥的⼀些函数"></a>关于cctype头⽂件⾥的⼀些函数</h1><p><code>#include&lt;cctype&gt;</code><br>总的来说常⽤的只有以下⼏个：<br>isalpha 字⺟（包括⼤写、⼩写）<br>islower（⼩写字⺟）<br>isupper（⼤写字⺟）<br>isalnum（字⺟⼤写⼩写+数字）<br>isblank（space和\t）<br>isspace（space、\t、\r、\n）</p>
<h1 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h1><p>auto是C++11⾥⾯的新特性，可以让编译器根据初始值类型直接推断变量的类型。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 本来set的迭代器遍历要这样写：</span><br><span class="line">for(set&lt;int&gt;::iterator it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">// 现在可以直接替换成这样的写法：</span><br><span class="line">for(auto it = s.begin(); it != s.end(); it++) &#123;</span><br><span class="line"> cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>stoi,stod,stof</p>
]]></content>
      <tags>
        <tag>C++基础知识</tag>
        <tag>C++11</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT刷题反思总结</title>
    <url>/2019/07/06/PAT%E5%88%B7%E9%A2%98%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="1001-A-B-Format-20-分"><a href="#1001-A-B-Format-20-分" class="headerlink" title="1001 A+B Format (20 分)"></a>1001 A+B Format (20 分)</h1><p>考虑情况不充足，测试案例不够多，导致提交了两次才ac。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="keyword">int</span> sum =a+b;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(sum)&gt;=<span class="number">1000000</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,%03d,%03d"</span>,sum/<span class="number">1000000</span>,<span class="built_in">abs</span>(sum%<span class="number">1000000</span>/<span class="number">1000</span>),<span class="built_in">abs</span>(sum%<span class="number">1000</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(sum)&gt;=<span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,%03d"</span>,sum/<span class="number">1000</span>,<span class="built_in">abs</span>(sum%<span class="number">1000</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1002-A-B-for-Polynomials-25-分"><a href="#1002-A-B-for-Polynomials-25-分" class="headerlink" title="1002 A+B for Polynomials (25 分)"></a>1002 A+B for Polynomials (25 分)</h1><p>花费时间1个小时。<br>出错分析：</p>
<ol>
<li>未考虑到正负系数相抵消的问题。</li>
<li>未考虑到给定的输入多项式，同样的项合并的问题。</li>
<li>自己代码上第二个多项式读入的长度写错，在自己测试时未查出bug。</li>
<li>自己测试时未考虑到所有可能的情况。</li>
</ol>
<h1 id="1003-Emergency-25-分"><a href="#1003-Emergency-25-分" class="headerlink" title="1003 Emergency (25 分)"></a>1003 Emergency (25 分)</h1><p>即是一般的Dijkstra和最短路径系列的问题，关键在于写熟练相关的代码。</p>
<h1 id="1004-Counting-Leaves-30-分"><a href="#1004-Counting-Leaves-30-分" class="headerlink" title="1004 Counting Leaves (30 分)"></a>1004 Counting Leaves (30 分)</h1><p>较简单，就是一个树的叶节点统计问题，我使用的是层次遍历，看很多人用的是DFS。<br>出错分析：<br>由于测试案例较少，导致放oj上跑只得了19分，然后自己多写了几个情况下的测试案例，最后发现是程序上的小bug，漏写问题，逻辑上无误，改正后AC。</p>
<h1 id="1005-Spell-It-Right-20-分"><a href="#1005-Spell-It-Right-20-分" class="headerlink" title="1005 Spell It Right (20 分)"></a>1005 Spell It Right (20 分)</h1><p>一开始选择int处理，后来换用long long（<code>scanf(&quot;%lld&quot;);printf(&quot;%lld&quot;);</code>），依然有一个节点未pass，再回过头来看题，发现范围是≤10^<br>​100，这就很过分了，只能使用char数组来处理，<strong>事实证明看清取值限定范围很重要！</strong></p>
<h1 id="1006-Sign-In-and-Sign-Out-25-分"><a href="#1006-Sign-In-and-Sign-Out-25-分" class="headerlink" title="1006 Sign In and Sign Out (25 分)"></a>1006 Sign In and Sign Out (25 分)</h1><p>我直接用sort做的，题目没给范围限制，简单AC到很奇怪。</p>
<h1 id="1007-Maximum-Subsequence-Sum-25-分"><a href="#1007-Maximum-Subsequence-Sum-25-分" class="headerlink" title="1007 Maximum Subsequence Sum (25 分)"></a>1007 Maximum Subsequence Sum (25 分)</h1><p>动态规划中的最大连续子序列和问题，记住下面的处理方法，写代码就很简单了。<br>令状态dp[i]表示以A[i]作为末尾的连续序列的最大和。<br>状态转移方程：dp[i] = max{ A[i], dp[i-1]+A[i] }<br>边界为：dp[0] = A[0]</p>
<h1 id="1009-Product-of-Polynomials-25-分"><a href="#1009-Product-of-Polynomials-25-分" class="headerlink" title="1009 Product of Polynomials (25 分)"></a>1009 Product of Polynomials (25 分)</h1><ol>
<li>double型数据的读入需要用lf，<code>scanf(&quot;%lf&quot;)</code></li>
<li>一开始写的循环未考虑到只有单个结果时不进入循环的情况，或有重复累加的情况。</li>
<li>测试点0一直不通过，后来发现是漏掉了正负系数相加互相抵消，最后不计入显示的情况。</li>
<li>对于多项式运算型的问题，最简单的方法是用数据进行，我的写法复杂了。</li>
</ol>
<h1 id="1010-Radix-25-分"><a href="#1010-Radix-25-分" class="headerlink" title="1010 Radix (25 分)"></a>1010 Radix (25 分)</h1><p>计算结果要用longlong存，不然会超时。。。。。。<br>还必须用二分查找，简单顺序查找也会超时。。。。。。<br><strong>这题没有AC，失败！</strong><br>第二天的挣扎之后：</p>
<ol>
<li>二分查找的left和right也必须用long long</li>
<li>所取的long long也有越界的可能，此时为负数，需要在二分查找中进行判断处理</li>
<li>初始上下界的选取也有窍门。<br> char it = *max_element(str.begin(),str.end());<br> long long low = (isdigit(it)?it - ‘0’:it - ‘a’ + 10) + 1;<br> long long high = max(low,num);</li>
</ol>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组（BIT）</title>
    <url>/2019/05/31/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%EF%BC%88BIT%EF%BC%89/</url>
    <content><![CDATA[<h1 id="lowbit运算"><a href="#lowbit运算" class="headerlink" title="lowbit运算"></a>lowbit运算</h1><p><code>#define lowbit(i) ((i) &amp; (-i))</code><br>含义：取i的二进制最右边的1和它右边所有0  或  能整除i的最大2的幂次</p>
<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p>定义：是一个用来记录和的数组，存放的是在i号位之前（含i号位）lowbit(i)个整数之和，覆盖长度是lowbit(i)。另外，树状数组的下标必须从1开始。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getSum函数返回前x个整数之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i&gt;<span class="number">0</span> ; i-=lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果要求数组下标在区间[x,y]内的数之和，可以转换成getSum(y)-getSum(x-1)来解决。</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//update函数将第x个整数加上v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= N ; i += lowbit(i))  <span class="comment">//注意i必须能取到N</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>统计序列中在元素左边比该元素小的元素个数。<br>问题：给定一个有N个正整数的序列A，对序列中的每个数，求出序列中它左边比它小的数的个数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(i) ((i) &amp; (-i))</span></span><br><span class="line"><span class="keyword">int</span> c[maxn];    <span class="comment">//树状数组</span></span><br><span class="line"><span class="comment">//update函数将第x个整数加上v</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= N ; i += lowbit(i))  <span class="comment">//注意i必须能取到N</span></span><br><span class="line">    &#123;</span><br><span class="line">        c[i] += v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//getSum函数返回前x个整数之和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i&gt;<span class="number">0</span> ; i-=lowbit(i))</span><br><span class="line">    &#123;</span><br><span class="line">        sum += c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    fill(c,c+maxn,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        update(x,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,getSum(x<span class="number">-1</span>));  <span class="comment">//查询当前小于x的数的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果要统计序列中在元素左边比该元素大的元素个数，等价于计算getSum(N)-getSum(A[i])，原始数组需要从右往左遍历。</strong></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2019/05/25/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>动态规划是一种用来解决一类最优化问题的算法思想，将一个复杂的问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解。</p>
<h1 id="动态规划的递归写法（记忆化搜索）"><a href="#动态规划的递归写法（记忆化搜索）" class="headerlink" title="动态规划的递归写法（记忆化搜索）"></a>动态规划的递归写法（记忆化搜索）</h1><p>动态规划记录子问题的解，来避免下次遇到相同的子问题时的重复计算。<br>以斐波那契数列的求解为例，为避免重复计算，开一个一维数组dp用以保存已经计算过的结果，其中dp[n]记录F(n)的结果，并用dp[n]=-1表示F(n)当前还没有被计算过。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line">fill(dp,dp+maxn,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">if</span>(dp[n] != <span class="number">-1</span>) <span class="keyword">return</span> dp[n];    <span class="comment">//已经计算过，直接返回结果</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        dp[n]=F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>);    <span class="comment">//计算F(n)，并保存至dp[n]</span></span><br><span class="line">        <span class="keyword">return</span> dp[n];    <span class="comment">//返回F(n)的结果</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="动态规划的递推写法"><a href="#动态规划的递推写法" class="headerlink" title="动态规划的递推写法"></a>动态规划的递推写法</h1><p>重点是找出<strong>状态转移方程</strong>和<strong>边界</strong>。<br>自底向上。</p>
<h2 id="最大连续子序列和"><a href="#最大连续子序列和" class="headerlink" title="最大连续子序列和"></a>最大连续子序列和</h2><p>令状态dp[i]表示以A[i]作为末尾的连续序列的最大和。<br>状态转移方程：dp[i] = max{ A[i], dp[i-1]+A[i] }<br>边界为：dp[0] = A[0]<br>练习题求解代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Result</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st,ed;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    freopen(<span class="string">"1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> k,temp;</span><br><span class="line">    <span class="keyword">int</span> A[maxn],dp[maxn];</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;=<span class="number">0</span>) flag = <span class="literal">true</span>;</span><br><span class="line">        A[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0 %d %d"</span>,A[<span class="number">0</span>],A[k<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dp[<span class="number">0</span>]=A[<span class="number">0</span>];</span><br><span class="line">    Result result[maxn];</span><br><span class="line">    result[<span class="number">0</span>].st=<span class="number">0</span>;</span><br><span class="line">    result[<span class="number">0</span>].ed=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result[i].st=result[i<span class="number">-1</span>].st;</span><br><span class="line">        <span class="keyword">if</span>(A[i]&gt;dp[i<span class="number">-1</span>]+A[i])</span><br><span class="line">        &#123;</span><br><span class="line">            result[i].st = i;</span><br><span class="line">            result[i].ed = i;</span><br><span class="line">            dp[i]=A[i];</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+A[i];</span><br><span class="line">            result[i].st = result[i<span class="number">-1</span>].st;</span><br><span class="line">            result[i].ed = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//dp[i]=max(A[i],dp[i-1]+A[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> MAX = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> reck = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            MAX = dp[i];</span><br><span class="line">            reck = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d"</span>,MAX,result[reck].st,result[reck].ed);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最长不下降子序列（LIS）"><a href="#最长不下降子序列（LIS）" class="headerlink" title="最长不下降子序列（LIS）"></a>最长不下降子序列（LIS）</h2><p>令dp[i]表示以A[i]结尾的最长不下降子序列长度。<br>状态转移方程：dp[i] = max{ 1, dp[i-1]+1 }<br>边界为：dp[i] = 1<br>LIS问题的模板代码如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">  dp[i]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;i ; j++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i]&gt;=A[j] &amp;&amp; (dp[j]+<span class="number">1</span> &gt; dp[i]))</span><br><span class="line">    &#123;</span><br><span class="line">      dp[i] = dp[j]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max(ans, dp[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="最长公共子序列（LCS）"><a href="#最长公共子序列（LCS）" class="headerlink" title="最长公共子序列（LCS）"></a>最长公共子序列（LCS）</h2><p>令dp[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度（下标从1开始）。<br>状态转移方程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[i] == B[j]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure></p>
<p>边界：dp[i][0] = dp[0][j] = 0;</p>
<p><strong>另外，例题中允许公共部分产生重复元素，修改后的模型如下：</strong><br>状态转移方程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(A[i] == B[j]) dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure></p>
<p>边界未改变。</p>
<h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>令dp[i][j]表示S[i]至S[j]所表示的子串是否是回文串，是则为1，不是为0.<br>状态转移方程：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(S[i] = S[j]) dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>边界：dp[i][i] = 1，dp[i][i+1] = (S[i] == S[i+1])?1:0<br>关键代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> L=<span class="number">3</span>;L&lt;=str.length();L++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i+L<span class="number">-1</span>&lt;str.length();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+L<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == str[j] &amp;&amp; dp[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                ans = L;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>子串端点的枚举问题：</strong>可以按子串的长度和子串的初始位置进行枚举，例如子串长度为L，左端点i，右端点i+L-1。</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>令dp[i][v]表示前i件物品恰好装入容量为v的背包中所能获得的最大价值。<br>状态转移方程：dp[i][v] = max{ dp[i-1][v] , dp[i-1][v-w[i]]+c[i]}<br>边界：dp[0][v] = 0<br><strong>另有方法优化其空间复杂度，开一个一维数组dp[v]，枚举方向改变为i从1到n，v从V到0</strong><br>新的状态转移方程为：dp[v] = max(dp[v], dp[v-w[i]]+c[i])</p>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>令dp[i][v]表示前i件物品恰好装入容量为v的背包中所能获得的最大价值。<br>状态转移方程：dp[i][v] = max{ dp[i-1][v] , dp[i][v-w[i]]+c[i]}<br>边界：dp[0][v] = 0<br><strong>另有方法优化其空间复杂度，开一个一维数组dp[v]，枚举方向改变为i从1到n，v从0到V正向枚举</strong><br>新的状态转移方程为：dp[v] = max(dp[v], dp[v-w[i]]+c[i])</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>当题目与序列或字符串（记为A）有关时，可以考虑把状态设计成下面两种形式，然后根据端点特点，取考虑状态转移方程.<br>1.1. 令dp[i]表示以A[i]结尾（或开头）的xxx。<br>1.2. 令dp[i][j]表示A[i]至A[j]区间的xxx。</li>
<li>分析题目中的状态需要几维来表示，然后对其中的每一维采取下面的某一个表述：<br>1.1. 恰好为i。<br>1.2. 前i。<br>在每一维的含义设置完毕之后，dp数组的含义就可以设置成“令dp数组表示恰好为i（或前i）、恰好为j（或前j）……的xxx”。接下来就可以通过端点的特点取考虑状态转移方程。</li>
</ol>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>关键路径</title>
    <url>/2019/05/24/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="AOV网和AOE网"><a href="#AOV网和AOE网" class="headerlink" title="AOV网和AOE网"></a>AOV网和AOE网</h1><p>AOV网（顶点活动网）是指用顶点表示活动，而用边集表示活动间优先关系的有向图。<br>AOE网（边活动网）是指用带权的边集表示活动，而用顶点表示事件的有向图，其中边权表示完成活动需要的时间。<br>AOE网中的最长路径被称为关键路径（<strong>关键路径就是AOE网的最长路径</strong>），其长度会等于整个工程的最短完成时间，而把关键路径上的活动称为<strong>关键活动</strong>，关键活动会影响整个工程的进度。</p>
<h1 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h1><p>即求解有向无环图（DAG）中最长路径的方法。<br>思路：</p>
<ol>
<li>按拓扑序和逆拓扑序分别计算各顶点（事件）的最早发生时间和最迟发生时间：<br>最早（拓扑序）：ve[j]=max{ve[i]+length[i-&gt;j]};<br>最迟（逆拓扑序）：vl[i] = min{vl[j]-length[i-&gt;j]};</li>
<li>用上面的结果计算各边（活动）的最早开始时间和最迟开始时间：<br>最早：e[i-&gt;j]=ve[i]<br>最迟：l[i-&gt;j]=vl[j]-length[i-&gt;j]</li>
<li>e[i-&gt;j]=l[i-&gt;j]的活动即为关键活动。</li>
</ol>
<p>代码如下（适用汇点确定且唯一的情况，以n-1号顶点为汇点为例）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; topOrder;  <span class="comment">//拓扑序列</span></span><br><span class="line"><span class="comment">//拓扑排序，顺便求ve数组</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        topOrder.push(u);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=G[u][i].v;</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//用ve[u]来更新u的所有后继结点v</span></span><br><span class="line">            <span class="keyword">if</span>(ve[u]+G[u][i].w &gt; ve[v])</span><br><span class="line">            &#123;</span><br><span class="line">                ve[v]=ve[u]+G[u][i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(topOrder.size() == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关键路径，不是有向无环图返回-1，否则返回关键路径长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CriticalPath</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(ve,ve+n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(topologicalSort()==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(vl,vl+n,ve[n<span class="number">-1</span>]);</span><br><span class="line">    <span class="comment">//直接使用topOrder出栈即为逆拓扑序列，求解vl数组</span></span><br><span class="line">    <span class="keyword">while</span>(!topOrder.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u= topOrder.top();</span><br><span class="line">        topOrder.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line">            <span class="keyword">if</span>(vl[v]-G[u][i].w &lt; vl[u])</span><br><span class="line">            &#123;</span><br><span class="line">                vl[u]=vl[v]-G[u][i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历邻接表的所有边，计算活动的最早开始时间e和最迟开始时间l</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i].v, w=G[u][i].w;</span><br><span class="line">            <span class="comment">//活动的最早开始时间e和最迟开始时间l</span></span><br><span class="line">            <span class="keyword">int</span> e=ve[u], l=vl[v]-w;</span><br><span class="line">            <span class="comment">//如果e==l，说明活动u-&gt;v是关键活动</span></span><br><span class="line">            <span class="keyword">if</span>(e==l)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d-&gt;%d\n"</span>, u, v);  <span class="comment">//输出关键活动</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ve[n<span class="number">-1</span>];  <span class="comment">//返回关键路径长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>如果事先不知道汇点编号，可以通过取ve数组的最大值来获得。于是只需要在fill函数之前添加如下语句，然后改变vl数组初始值即可。</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxLength=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ve[i]&gt;maxLength)</span><br><span class="line">    &#123;</span><br><span class="line">        maxLength = ve[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fill(vl,vl+n, maxLength);</span><br></pre></td></tr></table></figure></p>
<p>最后，使用动态规划的方法可以更简洁的求解关键路径。</p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/2019/05/24/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>有向无环图（DAG）</strong>是指一个有向图的任意顶点都无法通过一些有向边回到自身。<br><strong>拓扑排序</strong>是将有向无环图G的所有顶点排成一个线性序列，使得对图G中的任意两个顶点u、v，如果存在边u-&gt;v，那么在序列中u一定在v前面。这个序列又被称为拓扑序列。</p>
<h1 id="拓扑序列求法"><a href="#拓扑序列求法" class="headerlink" title="拓扑序列求法"></a>拓扑序列求法</h1><p>思路：</p>
<ol>
<li>定义一个队列Q，并把所有入度为0的结点加入队列。</li>
<li>取队首结点，输出。然后删去所有从它出发的边，并令这些边到达的顶点的入度减1，如果某个顶点的入度减为0，则将其加入队列。</li>
<li>反复进行2，直到队列为空。如果队列为空时入过队的结点数目恰好为N，说明拓扑排序成功，图G为有向无环图，否则拓扑排序失败，图G中有环。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[maxn];</span><br><span class="line"><span class="keyword">int</span> n,inDegree[maxn]; <span class="comment">//顶点数，入度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;  <span class="comment">//记录加入拓扑序列的顶点数</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(i)；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].clear();  <span class="comment">//选择性写</span></span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num==n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:如果要求有多个入度为0的顶点，选择编号最小的顶点，则把queue改成priority_queue，保持队首是最小元素即可（也可用set）。</p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树</title>
    <url>/2019/05/22/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<p>最小生成树是在一个给定的无向图中求一棵树，使得这棵树拥有图中的所有顶点，且所有边都是来自图中的边，并且满足整棵树的边权之和最小。<br>下述两种算法使用场景：<br><strong>如果是稠密图（边多），则用prim算法；如果是稀疏图（边少），则用kruskal算法。</strong></p>
<h1 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h1><p>prim算法与Dijkstra算法的思想几乎相同，只有在数组d[ ]的含义上有所区别，其中Dijkstra算法的数组d[ ]含义为起点s到达顶点Vi的最短距离，而prim算法的数组含义为顶点Vi与集合S的最短距离。伪代码如下:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Prim(G,d[])</span><br><span class="line">&#123;</span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环n次)</span><br><span class="line">    &#123;</span><br><span class="line">        u=使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">        记u已被访问;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v未被访问 &amp;&amp; 以u为中介点使得v与集合s的最短距离d[v]更优)</span><br><span class="line">            &#123;</span><br><span class="line">                将G[u][v]赋值给v与集合s的最短距离d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>邻接表版：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span> <span class="comment">//默认0号为初始点，函数返回最小生成树的边权之和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+MAXV,INF);</span><br><span class="line">    d[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;   <span class="comment">//存放最小生成树的边权之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            ans += d[u];    <span class="comment">//将与集合S距离最小的边加入最小生成树</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v= Adj[u][j].v;</span><br><span class="line">                <span class="keyword">int</span> dis= Adj[u][j].dis;</span><br><span class="line">                <span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; d[u]+dis &lt; d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v]=dis;    <span class="comment">//以u为中介点可以使v离集合s更近，将dis赋值给d[v]</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h1><p>思想是：每次选择图中最小边权的边，如果边两端的顶点在不同的连通块中，就把这条边加入最小生成树中。<br>伪代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    令最小生成树的边权之和为ans、最小生成树的当前边数Num_Edge;</span><br><span class="line">    将所有边按边权从小到大排序;</span><br><span class="line">    <span class="keyword">for</span>(从小到大枚举所有边)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(当前测试边的两个端点在不同的连通块中)</span><br><span class="line">        &#123;</span><br><span class="line">            将该测试边加入最小生成树中;</span><br><span class="line">            ans += 测试边的边权;</span><br><span class="line">            最小生成树的当前边数Num_Edge加<span class="number">1</span>;</span><br><span class="line">            当边数Num_Edge等于顶点数减<span class="number">1</span>时结束循环;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用并查集，代码实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u,v;    <span class="comment">//边的两个顶点编号</span></span><br><span class="line">    <span class="keyword">int</span> cost;   <span class="comment">//边权</span></span><br><span class="line">&#125;E[MAXE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a, edge b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> father[N];</span><br><span class="line"><span class="comment">//带路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x] == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = findFather(x);</span><br><span class="line">        father[x]=a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>,Num_Edge=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(E,E+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> faU=findFather(E[i].u);</span><br><span class="line">        <span class="keyword">int</span> faV=findFather(E[i].v);</span><br><span class="line">        <span class="keyword">if</span>(faU != faV)</span><br><span class="line">        &#123;</span><br><span class="line">            father[faU]=faV;</span><br><span class="line">            ans += E[i].cost;</span><br><span class="line">            Num_Edge++;</span><br><span class="line">            <span class="keyword">if</span>(Num_Edge == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Num_Edge != n<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路径刷题总结</title>
    <url>/2019/05/19/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="Public-Bike-Management"><a href="#Public-Bike-Management" class="headerlink" title="Public Bike Management"></a>Public Bike Management</h1><p>为了编写代码，可以把每个点的点权减去Cmax/2（简化的处理方法）。<br>这是多条最短路径和点权大小计算相关的问题，于是我用了Dijkstra的方法处理，题中所给的案例可以成功输出正确结果，但是这样处理并不正确！<br>因为minNeed和minRemain在路径上的传递不满足<strong>最优子结构（不是简单的相加过程）</strong>。也就是说，只有当所有路径都确定后，才能去选择最小的need和最小的remain。<br>因此本题需要使用Dijkstra算出所有最短路径，然后用DFS进行分析处理的做法！</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路径-Floyd算法</title>
    <url>/2019/05/14/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Floyd%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>用来解决全源最短路问题，即对给定的图G(V,E)，求任意两点u，v之间的最短路径长度，时间复杂度是O(n^3)（因此决定了顶点数n的限制约在200以内，使用邻接矩阵来实现非常合适）。<br>算法流程如下（伪代码）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">枚举顶点k 属于 [<span class="number">1</span>,n]</span><br><span class="line">    以顶点k作为中介点，枚举所有顶点对i和j（i，j都属于[<span class="number">1</span>,n]）</span><br><span class="line">        如果dis[i][k]+dis[k][j]&lt;dis[i][j]成立</span><br><span class="line">            赋值dis[i][j]=dis[i][k]+dis[k][j]</span><br></pre></td></tr></table></figure></p>
<p>举例实现：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,m; <span class="comment">//n为顶点数，m为边数</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[i][k]!=INF &amp;&amp; dis[k][j]!=INF &amp;&amp; dis[i][k]+dis[k][j] &lt; dis[i][j] )</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路径-Bellman-Ford算法和SPFA算法</title>
    <url>/2019/05/14/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Bellman-Ford%E7%AE%97%E6%B3%95%E5%92%8CSPFA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h1><p>Bellman-Ford算法可以解决单源最短路径问题，但也能处理有负边权的情况。<br>同Dijkstra算法一样，Bellman-Ford设置一个数组d存放从源点到达各个顶点的最短距离。<strong>同时Bellman-Ford算法返回一个bool值，如果其中存在从源点可达的负环，那么返回false，否则返回true。</strong><br>主要思路如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) <span class="comment">//执行n-1轮操作，其中n为顶点数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(each edge u-&gt;v) <span class="comment">//每轮操作都遍历所有边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+length[u-&gt;v] &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v]=d[u]+length[u-&gt;v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对每条边进行判断，看是否有负环，如果有，返回false</span></span><br><span class="line"><span class="keyword">for</span>(each edge u-&gt;v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[u]+length[u-&gt;v] &lt; d[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表举例实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+MAXN,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v= Adj[u][j].v;</span><br><span class="line">                <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis &lt; d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = d[u]+dis;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis =Adj[u][j].dis;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+d[s]&lt;d[v]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，此法在统计最短路径条数时，需要设置记录前驱的数组set<int> pre[MAXN]，当遇到一条和已有最短路径长度相同的路径时，必须重新计算最短路径条数</int></strong><br><strong>对PAT A1003题用Bellman算法重写</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> weight[MAXN];</span><br><span class="line"><span class="keyword">int</span> w[MAXN],num[MAXN];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bellman</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+MAXN,INF);</span><br><span class="line">    fill(w,w+MAXN,<span class="number">0</span>);</span><br><span class="line">    fill(num,num+MAXN,<span class="number">0</span>);</span><br><span class="line">    w[s]=weight[s];</span><br><span class="line">    num[s]=<span class="number">1</span>;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">0</span>;u&lt;n;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> v= Adj[u][j].v;</span><br><span class="line">                <span class="keyword">int</span> dis = Adj[u][j].dis;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+dis &lt; d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = d[u]+dis;</span><br><span class="line">                    w[v] = w[u]+weight[v];</span><br><span class="line">                    num[v]=num[u];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].insert(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+dis == d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(w[u]+weight[v] &gt; w[v])</span><br><span class="line">                    &#123;</span><br><span class="line">                        w[v]=w[u]+weight[v];</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre[v].insert(u);</span><br><span class="line">                    num[v]=<span class="number">0</span>; <span class="comment">//重新统计num[v]</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = pre[v].begin();it != pre[v].end();it++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        num[v]+=num[*it];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不进行负环判断</span></span><br><span class="line">    <span class="comment">// for(int u=0;u&lt;n;u++)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     for(int j=0;j&lt;Adj[u].size();j++)</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         int v = Adj[u][j].v;</span></span><br><span class="line">    <span class="comment">//         int dis =Adj[u][j].dis;</span></span><br><span class="line">    <span class="comment">//         if(d[u]+d[s]&lt;d[v]) return false;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// return true;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h1><p>SPFA算法是对Bellman算法的优化，在Bellman算法的过程中注意到，只有当某个顶点u的d[u]值改变时，从它出发的边的邻接点v的d[v]值才可能被改变，代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">源点s入队;</span><br><span class="line"><span class="keyword">while</span>(队列非空)</span><br><span class="line">&#123;</span><br><span class="line">    取出队首元素u;</span><br><span class="line">    <span class="keyword">for</span>(u的所有邻接边u-&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+dis &lt; d[v])</span><br><span class="line">        &#123;</span><br><span class="line">            d[v]=d[u]+dis;</span><br><span class="line">            <span class="keyword">if</span>(v当前不在队列)</span><br><span class="line">            &#123;</span><br><span class="line">                v入队;</span><br><span class="line">                <span class="keyword">if</span>(v入队次数大于n<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    说明有可达负环，<span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>邻接表版本的例子<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAXN],num[MAXN];</span><br><span class="line"><span class="keyword">bool</span> inq[MAXN]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+MAXN,INF);</span><br><span class="line">    fill(num,num+MAXN,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    inq[s]=<span class="literal">true</span>;</span><br><span class="line">    num[s]++;  <span class="comment">//源点入队次数加1</span></span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        inq[u]=<span class="literal">false</span>; <span class="comment">//设置u不在队列中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v= Adj[u][j].v;</span><br><span class="line">            <span class="keyword">int</span> dis= Adj[u][j].dis;</span><br><span class="line">            <span class="comment">//松弛操作</span></span><br><span class="line">            <span class="keyword">if</span>(d[u]+dis &lt; d[v])</span><br><span class="line">            &#123;</span><br><span class="line">                d[v]=d[u]+dis;</span><br><span class="line">                <span class="keyword">if</span>(!inq[v])  <span class="comment">//如果v不在队列中</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Q.push(v);</span><br><span class="line">                    inq[v]=<span class="literal">true</span>;</span><br><span class="line">                    num[v]++;</span><br><span class="line">                    <span class="keyword">if</span>(num[v]&gt;=n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//有可达负环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的最短路径-Dijkstra算法</title>
    <url>/2019/05/08/%E5%9B%BE%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Dijkstra%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>Dijkstra算法解决的是单源最短路问题。<br><strong>Dijkstra算法只能应对所有边权都是非负数的情况，如果边权出现负数，这时需要使用别的算法，比如SPFA。</strong><br>伪代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//G为图，数组d为源点到达各点的最短路径长度，s为起点</span></span><br><span class="line">Dijkstra(G,d[],s)</span><br><span class="line">&#123;</span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环n次)&#123;</span><br><span class="line">        u=使d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">        记u已被访问;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v未被访问&amp;&amp;以u为中介点使s到顶点v的最短距离d[v]更优)&#123;</span><br><span class="line">                优化d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>//正常写法是复杂度O(V^2)级别的，下面代码使用优先队列对寻找最小d[u]的过程进行优化，使得时间复杂度降为O(VlogV+E)。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表版正常写法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV=<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">1000000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+MAXV,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j] &lt; MIN)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span> &amp;&amp; d[u]+Adj[u][j].dis &lt; d[v])&#123;</span><br><span class="line">                d[v] = d[u]+Adj[u][j].dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>对于无向边情况，只需要把无向边当成两条指向相反的有向边即可。</strong></p>
<h1 id="最短路径的求法"><a href="#最短路径的求法" class="headerlink" title="最短路径的求法"></a>最短路径的求法</h1><p>令pre[v]表示从起点s到顶点v的最短路径上v的前一个顶点的编号。做如下改动：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) pre[i]=i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在d[v]=d[u]+Adj[u][j].dis后加入</span></span><br><span class="line">pre[v]=u;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求整条路径，可以递归进行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==s)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(s,pre[v]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="题目可能的考查情况"><a href="#题目可能的考查情况" class="headerlink" title="题目可能的考查情况"></a>题目可能的考查情况</h1><p>有两条及以上的最短路径，给出第二标尺，要求选择最短路径中第二标尺最优的一条路径。<br>处理办法都是增加一个新的数组，在Dijkstra算法中修改<strong>优化d[v]</strong>步骤即可。<br>可能的第二标尺：</p>
<ol>
<li>每条边增加边权，求在最短路径有多条时花费之和最小的路径。(cost[u][v]表示花费，c[u]表示起点s到达顶点u的最少花费)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+Adj[u][j].dis &lt; d[v])&#123;</span><br><span class="line">            d[v]=d[u]+Adj[u][j].dis;</span><br><span class="line">            c[v]=c[u]+cost[u][v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(d[u]+Adj[u][j].dis == d[v] &amp;&amp; c[u]+cost[u][v] &lt; c[v])</span><br><span class="line">            c[v]=c[u]+cost[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>每个点增加点权，求在最短路径有多条时点权之和最大的路径。(weight[v]表示v的点权，w[u]表示起点s到达顶点u的最大点权和)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+Adj[u][j].dis &lt; d[v])&#123;</span><br><span class="line">            d[v]=d[u]+Adj[u][j].dis;</span><br><span class="line">            w[v]=w[u]+weight[v];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+Adj[u][j].dis == d[v] &amp;&amp; w[u]+weight[v] &gt; w[v])</span><br><span class="line">            w[v]=w[u]+weight[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>有多少条最短路径。(num[u]表示起点s到达顶点u的最短路径条数，初始化时num[s]=1，其余的num[u]为0)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">    <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[u]+Adj[u][j].dis &lt; d[v])&#123;</span><br><span class="line">            d[v]=d[u]+Adj[u][j].dis;</span><br><span class="line">            num[v]=num[u];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+Adj[u][j].dis == d[v])</span><br><span class="line">            num[v]+=num[u];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="Emergency"><a href="#Emergency" class="headerlink" title="Emergency"></a>Emergency</h2><p>书上用的是邻接矩阵写的，我用的是邻接表。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">int</span> d[MAXN];</span><br><span class="line"><span class="keyword">int</span> weight[MAXN];</span><br><span class="line"><span class="keyword">int</span> w[MAXN];</span><br><span class="line"><span class="keyword">int</span> num[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,dis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    fill(d,d+MAXN,INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    fill(num,num+MAXN,<span class="number">0</span>);</span><br><span class="line">    num[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)</span><br><span class="line">            &#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v=Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v] == <span class="literal">false</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+Adj[u][j].dis&lt;d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v] = d[u]+Adj[u][j].dis;</span><br><span class="line">                    w[v] = w[u]+weight[v];</span><br><span class="line">                    num[v] = num[u];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(d[u]+Adj[u][j].dis==d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    num[v]+=num[u];</span><br><span class="line">                    <span class="keyword">if</span>(w[u]+weight[v]&gt;w[v]) w[v]=w[u]+weight[v];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    freopen(<span class="string">"1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> m,s,u,temp;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;n,&amp;m,&amp;s,&amp;u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        w[i]=weight[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c1,c2,l;</span><br><span class="line">    Node now;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;c1,&amp;c2,&amp;l);</span><br><span class="line">        now.dis=l;</span><br><span class="line">        now.v=c2;</span><br><span class="line">        Adj[c1].push_back(now);</span><br><span class="line">        now.v=c1;</span><br><span class="line">        Adj[c2].push_back(now);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,num[u]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,w[u]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="更复杂的情况的处理方法：Dijkstra-DFS"><a href="#更复杂的情况的处理方法：Dijkstra-DFS" class="headerlink" title="更复杂的情况的处理方法：Dijkstra+DFS"></a>更复杂的情况的处理方法：Dijkstra+DFS</h1><p>思路：先在Dijkstra算法中记录下所有最短路径（只考虑距离），然后从这些最短路径中选出一条第二标尺最优的路径。<br>pre数组定义为vector类型以应对有多个前驱的情况，也可以把pre数组设置为set<int>数组，此时可以用algorithm头文件下的count()函数来查找set中某个键值出现的次数<code>pre[v].count(u)</code>。<br>完整的Dijkstra算法代码如下；<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fill(d,d+MAXV,INF);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">-1</span>,MIN=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j]==<span class="literal">false</span> &amp;&amp; d[j]&lt;MIN)&#123;</span><br><span class="line">                u=j;</span><br><span class="line">                MIN=d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u==<span class="number">-1</span>)<span class="keyword">return</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Adj[u].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> v = Adj[u][j].v;</span><br><span class="line">            <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(d[u]+Adj[u][j].dis &lt; d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    d[v]= d[u]+Adj[u][j].dis;</span><br><span class="line">                    pre[v].clear();         <span class="comment">//pre不需要初始化</span></span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(d[u]+Adj[u][j].dis == d[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></p>
<p>遍历所有最短路径，找出一条使第二标尺最优的路径。DFS的代码如下：<br><strong>注意，存放在tempPath和path中的路径结点是逆序的，因此访问结点需要倒着进行</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> optValue;   <span class="comment">//第二标尺最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path,tempPath;  <span class="comment">//最优路径、临时路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v==st)   <span class="comment">//如果到达了叶子结点st（即起点）</span></span><br><span class="line">    &#123;</span><br><span class="line">        tempPath.push_back(v);</span><br><span class="line">        <span class="keyword">int</span> value;</span><br><span class="line">        计算路径tempPath上的value值;</span><br><span class="line">        <span class="keyword">if</span>(value优于optValue)</span><br><span class="line">        &#123;</span><br><span class="line">            optValue = value;</span><br><span class="line">            path = tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pre[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历</title>
    <url>/2019/05/04/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>用二维数组，适用于顶点数目比较小的情况。</p>
<h2 id="邻接表（vector版）"><a href="#邻接表（vector版）" class="headerlink" title="邻接表（vector版）"></a>邻接表（vector版）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    Node(<span class="keyword">int</span> _v,<span class="keyword">int</span> _w): v(_v),w(_w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[maxn];</span><br><span class="line">Adj[<span class="number">1</span>].push_back(Node(<span class="number">3</span>,<span class="number">4</span>));</span><br></pre></td></tr></table></figure>
<h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><p><strong>由于关于计算层数我老是搞混，所以下面代码增加层数记录的部分</strong></p>
<h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">DFS(u)</span><br><span class="line">&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(从u出发能到达的所有顶点v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">DFSTrave(G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">BFS(u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    inq[u]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q非空)</span><br><span class="line">    &#123;</span><br><span class="line">        取出q的队首元素u进行访问</span><br><span class="line">        <span class="keyword">for</span>(从u出发可达的所有顶点v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(inq[v]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                将v入队；</span><br><span class="line">                inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">BFSTrave(G)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(G的所有顶点u)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inq[u]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            BFS(u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BFS练习题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    Node()&#123;&#125;</span><br><span class="line">    Node(<span class="keyword">int</span> _v):v(_v)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; G[maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> l;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> &amp;times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;Node&gt; q;</span><br><span class="line">    Node first;</span><br><span class="line">    first.v = start;</span><br><span class="line">    first.layer = <span class="number">0</span>;</span><br><span class="line">    q.push(first);</span><br><span class="line">    inq[first.v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node topNode = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> u = topNode.v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[u].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Node next = G[u][i];</span><br><span class="line">            next.layer = topNode.layer+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(inq[next.v] == <span class="literal">false</span> &amp;&amp; next.layer &lt;= l)</span><br><span class="line">            &#123;</span><br><span class="line">                q.push(next);</span><br><span class="line">                inq[next.v] = <span class="literal">true</span>;</span><br><span class="line">                times++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    freopen(<span class="string">"1.txt"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// ONLINE_JUDGE</span></span></span><br><span class="line">    <span class="keyword">int</span> n,m,k,ui;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;l);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ui);</span><br><span class="line">            G[ui].push_back(Node(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;ui);</span><br><span class="line">        BFS(ui,temp);</span><br><span class="line">        result.push_back(temp);</span><br><span class="line">        temp = <span class="number">0</span>;</span><br><span class="line">        fill(inq,inq+maxn,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,result[i]);</span><br><span class="line">        <span class="keyword">if</span>(i!=result.size()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h1><h2 id="Battle-over-cities"><a href="#Battle-over-cities" class="headerlink" title="Battle over cities"></a>Battle over cities</h2><p>无向图删除顶点和链接的边后，需要增加多少条边才能使剩下的图连通。</p>
<ol>
<li>需要添加的边数等于连通块个数减一；</li>
<li><p>无向图连通块个数的求解方法：<br>a. 图的遍历<br>b. 并查集，判断无向图每条边的两个顶点是否在同一个集合内，如果在同一个集合内，则不做处理，否则，将这两个顶点加入同一个集合，最后统计所有集合的个数即可。</p>
</li>
<li><p>删除顶点，当访问到该顶点时返回即可。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>常用算法</tag>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2019/05/04/%E5%A0%86/</url>
    <content><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆是一棵完全二叉树。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> heap[maxn],n=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对heap数组在[low,high]范围进行向下调整</span></span><br><span class="line"><span class="comment">//其中low为欲调整结点的数组下标，high一般为堆的最后一个元素的数组下标。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downAdjust</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=low,j=i*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j+<span class="number">1</span> &lt;= high &amp;&amp; heap[j+<span class="number">1</span>]&gt;heap[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&gt;heap[i])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap[i],heap[j]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i*<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下键堆倒着进行枚举，保证每个结点都是以其为根结点的子树中的权值最大的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createHeap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        downAdjust(i,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteTop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    heap[<span class="number">1</span>]=heap[n--]; <span class="comment">//用最后一个元素覆盖堆顶元素，并让元素个数减1</span></span><br><span class="line">    downAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往堆里添加元素，放在数组最后，然后进行向上调整</span></span><br><span class="line"><span class="comment">//对heap数组在[low,high]范围进行向上调整</span></span><br><span class="line"><span class="comment">//其中low一般设置为1，high表示欲调整结点的数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upAdjust</span><span class="params">(<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=high,j=i/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&gt;=low)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(heap[j]&lt;heap[i])</span><br><span class="line">        &#123;</span><br><span class="line">            swap(heap[j],heap[i]);</span><br><span class="line">            i=j;</span><br><span class="line">            j=i/<span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    heap[++n]=x;</span><br><span class="line">    upAdjust(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    createHeap();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(heap[i],heap[<span class="number">1</span>]);</span><br><span class="line">        downAdjust(<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>哈夫曼树</title>
    <url>/2019/05/04/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<h1 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h1><p>叶子结点的路径长度是指从根结点出发到达该结点所经过的边数，把叶子结点的权值乘以其路径长度的结果称为这个叶子结点的<strong>带权路径长度</strong>。<br><strong>树的带权路径长度</strong>等于它所有叶子结点的带权路径长度之和。<br>带权路径长度最小的树被称为<strong>哈夫曼树（最优二叉树）</strong>。<br>而在实际场景中，不需要真的去构建一棵哈夫曼树，只需要能得到最终的带权路径长度即可，因此只需要掌握<strong>哈夫曼树的构建思想</strong>：<br>反复选择两个最小的元素，合并，直到只剩下一个元素。一般可以使用优先队列来执行。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> temp,x,y,ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;temp);</span><br><span class="line">        q.push(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求带权路径长度的过程</span></span><br><span class="line">    <span class="keyword">while</span>(q.size()&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        y = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        q.push(x+y);</span><br><span class="line">        ans += x+y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><p>前缀编码：不产生混淆，让解码能够正常进行。<br>哈夫曼编码：使给定字符串编码成01串后长度最短的前缀编码。（是针对确定的字符串来讲的）</p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2019/05/03/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol>
<li>合并：合并两个集合</li>
<li>查找：判断两个元素是否在一个集合</li>
</ol>
<p>并查集用一个数组<code>int father[N];</code>来实现的，<code>father[i]</code>表示元素i的父亲结点，如果<code>father[i]==i</code>说明元素i是该集合的根结点，对于同一个集合来说只存在一个根结点，且将其作为所属集合的标识。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line">    father[i]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找操作是对给定的结点寻找其根结点的过程。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递推方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x])</span><br><span class="line">    &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> findFather(father[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>一般先判断两个元素是否属于同一个集合，只有当两个元素属于不同的集合时才合并，而合并的过程一般是把其中一个集合的根结点的父亲指向另一个集合的根结点。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> faA = findFather(a);</span><br><span class="line">    <span class="keyword">int</span> faB = findFather(b);</span><br><span class="line">    <span class="keyword">if</span>(faA != faB)</span><br><span class="line">    &#123;</span><br><span class="line">        father[faA] = faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h1><p>优化并查集的查询操作<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x;</span><br><span class="line">    <span class="keyword">while</span>(x != father[x])</span><br><span class="line">    &#123;</span><br><span class="line">        x = father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a != father[a])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> z = a;</span><br><span class="line">        a = father[a];</span><br><span class="line">        father[z] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFather</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a = findFather(x);</span><br><span class="line">        father[x] = a;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h1><p>isRoot[]处理集合个数和大小问题。</p>
]]></content>
      <tags>
        <tag>常用算法</tag>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2019/05/01/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>AVL树仍然是一棵二叉查找树，只是增加了平衡的要求，即对AVL树的任意结点来说，其左子树和右子树的高度之差的绝对值不超过1，其中左子树和右子树的高度之差称为该结点的平衡因子。只要保证每个结点平衡因子的绝对值不超过1就行，于是在结点的结构中加入一个height变量，用来记录以当前结点为根结点的子树的高度。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, height;</span><br><span class="line">    node *lchild,*rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;v = v;</span><br><span class="line">    Node-&gt;height=<span class="number">1</span>;</span><br><span class="line">    Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBalanceFactor</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getHeight(root-&gt;rchild)-getHeight(root-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHeight</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root-&gt;height=max(getHeight(root-&gt;rchild),getHeight(root-&gt;lchild))+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>左旋：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L</span><span class="params">(node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* temp = root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild = temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>右旋：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R</span><span class="params">(node* &amp;root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* temp = root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild = temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild = root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要把最靠近插入结点的失衡结点调整到正常，路径上的所有结点就都会平衡。<br>最靠近插入结点的失衡结点的平衡因子只可能是2或者-2，这两种情况完全对称，因此下面主要讨论平衡因子是2的情形。</p>
<table>
<thead>
<tr>
<th style="text-align:center">树型</th>
<th style="text-align:center">判定条件</th>
<th style="text-align:center">调整方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LL</td>
<td style="text-align:center">BF(root)=2,BF(root-&gt;lchild)=1</td>
<td style="text-align:center">对root进行右旋</td>
</tr>
<tr>
<td style="text-align:center">LR</td>
<td style="text-align:center">BF(root)=2,BF(root-&gt;lchild)=-1</td>
<td style="text-align:center">先对root-&gt;lchild进行左旋，再对root进行右旋</td>
</tr>
<tr>
<td style="text-align:center">RR</td>
<td style="text-align:center">BF(root)=-2,BF(root-&gt;rchild)=-1</td>
<td style="text-align:center">对root进行左旋</td>
</tr>
<tr>
<td style="text-align:center">RL</td>
<td style="text-align:center">BF(root)=-2,BF(root-&gt;rchild)=1</td>
<td style="text-align:center">先对root-&gt;rchild进行右旋，再对root进行左旋</td>
</tr>
</tbody>
</table>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(v &lt; root-&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lchild,v);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;lchild) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,v);</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        <span class="keyword">if</span>(getBalanceFactor(root) == <span class="number">-2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(getBalanceFactor(root-&gt;rchild) == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>常用算法</tag>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树</title>
    <url>/2019/04/30/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树(BST)"></a>二叉查找树(BST)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>左子树上所有结点均小于或等于根结点，右子树上所有结点均大于根结点。</p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"search failed\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x==root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        search(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        search(root-&gt;lchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于一棵二叉查找树来说，查找某个数据域的结点一定是沿着确定的路径进行的，因此如果需要查找的值在二叉查找树中查找失败，那么说明查找失败的地方一定是结点需要插入的地方。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;data = x;</span><br><span class="line">        root-&gt;lchild=root-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == root-&gt;data) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; root-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除某个结点后，需要进行相应的调整使得删除结点后的二叉树还是一棵二叉查找树。<br>把二叉查找树中比被删除结点权值小的最大结点称为该结点的前驱，而把比被删除结点权值大的最小结点称为该结点的后继，显然，被删除结点的前驱是该结点左子树中的最右结点，后继则是该结点右子树中的最左结点。下面给出两个辅助函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//寻找以root为根结点的树中的最大权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMax</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = root-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找以root为根结点的树中的最小权值结点</span></span><br><span class="line"><span class="function">node* <span class="title">findMin</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = root-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>删除操作代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(node* &amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root =<span class="literal">NULL</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            node* pre = findMax(root-&gt;lchild);</span><br><span class="line">            root-&gt;data = pre-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;lchild,pre-&gt;data);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            node* next = findMin(root-&gt;rchild);</span><br><span class="line">            root-&gt;data = next-&gt;data;</span><br><span class="line">            deleteNode(root-&gt;rchild,next-&gt;data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;data &gt; x)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode(root-&gt;lchild, x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        deleteNode(root-&gt;rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>对二叉查找树进行中序遍历，遍历的结果是有序的。</p>
<h1 id="刷题总结"><a href="#刷题总结" class="headerlink" title="刷题总结"></a>刷题总结</h1><h2 id="Complete-Binary-Search-Tree"><a href="#Complete-Binary-Search-Tree" class="headerlink" title="Complete Binary Search Tree"></a>Complete Binary Search Tree</h2><p>构建完全二叉查找树<br>思路：首先根据给定大小构造一棵完全二叉树（大小已知则完全二叉树的形状就确定了），因为对于二叉查找树来说，中序遍历的结果是有序的，于是将给定序列从小到大排列，然后对完全二叉树进行中序遍历，同时把给定序列的值填入树中，得到了一棵完全二叉查找树。</p>
]]></content>
      <tags>
        <tag>常用算法</tag>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>树的遍历总结</title>
    <url>/2019/04/25/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="树的遍历代码实现"><a href="#树的遍历代码实现" class="headerlink" title="树的遍历代码实现"></a>树的遍历代码实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[index].data = v;</span><br><span class="line">    Node[index].child.clear();</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, Node[root].data);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PreOrder(Node[root].child[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> front = Q.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Node[root].data);</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[root].child.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Q.push(Node[root].child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Total-Sales-of-Supply-Chain"><a href="#Total-Sales-of-Supply-Chain" class="headerlink" title="Total Sales of Supply Chain"></a>Total Sales of Supply Chain</h1><p>题目不难，我用的是BFS（树的层次遍历）设置了层数后计算得到的，书上给出的解法是用的DFS<br><strong>错误点</strong><br><strong>在读入double类型的时候，以前亲手做的次数太少，忘了要用%lf，导致读入的一直为0，找了很久才找到问题所在</strong><br><strong>记住</strong><br><strong><code>scanf(&quot;%lld&quot;,&amp;longlongtype);  scanf(&quot;%lf&quot;,&amp;doubletype); scanf(&quot;%f&quot;,&amp;floattype)</code></strong><br><strong>另外<code>printf(&quot;%lld&quot;,longlongtype);  printf(&quot;%f %f&quot;,doubletype,floattype)</code></strong><br>以下为本题代码<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    <span class="keyword">int</span> amount;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">    node()</span><br><span class="line">    &#123;</span><br><span class="line">        amount=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Node[now].child.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> child = Node[now].child[i];</span><br><span class="line">            q.push(child);</span><br><span class="line">            Node[child].layer = Node[now].layer+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,c;</span><br><span class="line">    <span class="keyword">double</span> price,r;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %lf %lf"</span>,&amp;n,&amp;price,&amp;r);</span><br><span class="line">    r = <span class="number">1</span>+<span class="number">0.01</span>*r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp2;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp2);</span><br><span class="line">            Node[i].amount=temp2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">                Node[i].child.push_back(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Node[<span class="number">0</span>].layer=<span class="number">0</span>;</span><br><span class="line">    LayerOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Node[i].amount != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result=result+<span class="built_in">pow</span>(r,Node[i].layer)*Node[i].amount*price;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.1f"</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Counting-leaves"><a href="#Counting-leaves" class="headerlink" title="Counting leaves"></a>Counting leaves</h1><p>数每一层的叶子节点并输出，我用的BFS的做法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> layer;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(index);</span><br><span class="line">    <span class="keyword">int</span> lay =<span class="number">0</span>;</span><br><span class="line">    node[index].layer=lay;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        <span class="keyword">if</span>(node[now].layer != lay)</span><br><span class="line">        &#123;</span><br><span class="line">            lay = node[now].layer;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,l);</span><br><span class="line">            l=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(node[now].child.empty()) l++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node[now].child.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c=node[now].child[i];</span><br><span class="line">            q.push(c);</span><br><span class="line">            node[c].layer=lay+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> id,k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;id,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            node[id].child.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> leaves=<span class="number">0</span>;</span><br><span class="line">    LayerOrder(<span class="number">1</span>,leaves);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>书中给的DFS做法如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vector&lt;int&gt; G[MAXV]表示树</span></span><br><span class="line"><span class="comment">//int leaf[MAXV]存放每层的叶子结点个数</span></span><br><span class="line"><span class="comment">//max_h记录树的深度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    max_h = max(max_h,h);</span><br><span class="line">    <span class="keyword">if</span>(G[index].size()==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        leaf[h]++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G[index].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(G[index][i],h+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Path-of-Equal-Weight"><a href="#Path-of-Equal-Weight" class="headerlink" title="Path of Equal Weight"></a>Path of Equal Weight</h1><p>找到叶子结点的权值和等于给定权值的所有路径，用DFS处理，我成功写出来了！我很骄傲！(注意要判断是否是叶节点，一开始没有判断，所以多了一条路径)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125;node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; one;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node[a].weight&gt;node[b].weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sum, <span class="keyword">int</span>&amp; pi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum += node[index].weight;</span><br><span class="line">    one.push_back(node[index].weight);</span><br><span class="line">    <span class="keyword">if</span>(sum == s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[index].child.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            path[pi]=one;</span><br><span class="line">            pi++;</span><br><span class="line">            one.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            one.pop_back();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        one.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;node[index].child.size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(node[index].child[i],sum,pi);</span><br><span class="line">    &#125;</span><br><span class="line">    one.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;s);</span><br><span class="line">    <span class="keyword">int</span> w,id,k,temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">        node[i].weight=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;id,&amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">            node[id].child.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(node[id].child.begin(),node[id].child.end(),cmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pi=<span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">00</span>,sum,pi);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pi;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;path[i].size()<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,path[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,path[i][path[i].size()<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(i!=pi<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历刷题小结</title>
    <url>/2019/04/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E5%88%B7%E9%A2%98%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li>二叉树的静态写法中找根结点，只需要找到一个结点，它不是任何结点的孩子即可。</li>
<li>scanf的%c格式可以读入换行符，因此有时候需要在每行输入前把上一行的换行符接收（可用getchar）。</li>
<li>针对上一条的情况，可以用scanf(“%*c”)，这样指定了scanf中接收一个字符。</li>
<li>为实现输出的格式问题，可以自行重写print函数(以下代码为本题所重写的函数，针对不同情况可以有不同的重写方法，这里只是提供一种思路)<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,id);</span><br><span class="line">    num++;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;n) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次完全输出之后需要进行num=0归零操作。</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的重建问题</title>
    <url>/2019/04/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E5%BB%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>本文只讨论一个问题，<strong>若给出中序序列和层次序列，求构造相应的二叉树。</strong><br>参考资料为：<a href="https://blog.csdn.net/matrixdwy/article/details/3111808" target="_blank" rel="noopener">https://blog.csdn.net/matrixdwy/article/details/3111808</a></p>
<h1 id="各项数据结构表示"><a href="#各项数据结构表示" class="headerlink" title="各项数据结构表示"></a>各项数据结构表示</h1><p>设层次序列为：<br><code>lev[7]={4,1,6,3,5,7,2}</code><br>中序序列为：<br><code>in[7]={1,2,3,4,5,6,7}</code><br>还原的二叉树结点结构为:<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">    node()</span><br><span class="line">    &#123;</span><br><span class="line">        data=lchild=rchild=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>二叉树存放的结构为：<br><code>node tree[7]</code></p>
<h1 id="根据层次序列和中序序列重建二叉树过程"><a href="#根据层次序列和中序序列重建二叉树过程" class="headerlink" title="根据层次序列和中序序列重建二叉树过程"></a>根据层次序列和中序序列重建二叉树过程</h1><p><strong>处理思路</strong><br>访问lev第一个结点，位置为index1<br>找到lev[index1]在in中对应的位置为index2后，设置tree[index2].data=lev[index1]。</p>
<ul>
<li>先向tree的index2位置的左边查找，找第一个tree.data不为0的结点：<br>1) 找到，若该结点的右孩子为0，则设置该结点的右孩子为index2，break；否则进行下一步<br>2) 未找到，进行下一步</li>
<li>向tree的index2位置的右边查找，找第一个tree.data不为0的结点:<br>1) 找到，若该结点的左孩子为0，则设置该结点的左孩子为index2，break；否则进行下一步<br>2) 未找到，进行下一步<br>如果向左和向右都未找到，则index2位置为根结点位置，设置<code>int root=index2</code>，访问lev下一个结点，即index1++<br>如果找到，访问lev下一个结点，即index1++</li>
</ul>
<p><strong>示例如下</strong></p>
<ol>
<li><p>初始情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4  1  6  3  5  7  2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   0  0  0  0  0  0  0</span><br><span class="line">tree.lchild 0  0  0  0  0  0  0</span><br><span class="line">tree.rchild 0  0  0  0  0  0  0</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问lev第一个结点，index1=0，index2=3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev        [4] 1  6  3  5  7  2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   0  0  0  4  0  0  0</span><br><span class="line">tree.lchild 0  0  0  0  0  0  0</span><br><span class="line">tree.rchild 0  0  0  0  0  0  0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时向左和向右都为找到，root=index2=3;</p>
<ol start="3">
<li>访问lev第二个结点，index1=1，index2=0<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4 [1] 6  3  5  7  2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   1  0  0  4  0  0  0</span><br><span class="line">tree.lchild 0  0  0  1  0  0  0</span><br><span class="line">tree.rchild 0  0  0  0  0  0  0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>向右找到，设置tree.data=4的左孩子为1</p>
<ol start="4">
<li>访问lev第三个结点，index1=2，index2=5<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4  1 [6] 3  5  7  2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   1  0  0  4  0  6  0</span><br><span class="line">tree.lchild 0  0  0  1  0  0  0</span><br><span class="line">tree.rchild 0  0  0  6  0  0  0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>向左找到，设置tree.data=4的右孩子为6</p>
<ol start="5">
<li><p>访问lev第四个结点，index1=3，index2=2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4  1  6 [3] 5  7  2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   1  0  3  4  0  6  0</span><br><span class="line">tree.lchild 0  0  0  1  0  0  0</span><br><span class="line">tree.rchild 3  0  0  6  0  0  0</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问lev第五个结点，index1=4，index2=4</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4  1  6  3 [5] 7  2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   1  0  3  4  5  6  0</span><br><span class="line">tree.lchild 0  0  0  1  0  5  0</span><br><span class="line">tree.rchild 3  0  0  6  0  0  0</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问lev第六个结点，index1=5，index2=6</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4  1  6  3  5 [7] 2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   1  0  3  4  5  6  7</span><br><span class="line">tree.lchild 0  0  0  1  0  5  0</span><br><span class="line">tree.rchild 3  0  0  6  0  7  0</span><br></pre></td></tr></table></figure>
</li>
<li><p>访问lev第七个结点，index1=6，index2=1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lev         4  1  6  3  5 [7] 2</span><br><span class="line">in          1  2  3  4  5  6  7</span><br><span class="line">tree.data   1  2  3  4  5  6  7</span><br><span class="line">tree.lchild 0  0  2  1  0  5  0</span><br><span class="line">tree.rchild 3  0  0  6  0  7  0</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建得到的二叉树如下</p>
<pre><code>4
</code></pre><p> 1           6</p>
<pre><code>3      5    7
</code></pre><p>  2</p>
</li>
</ol>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>本代码中将各值初始化为了-1，数组从0开始存储，lchild和rchild的值为数组的索引值。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data,lchild,rchild;</span><br><span class="line">    node()</span><br><span class="line">    &#123;</span><br><span class="line">        data=lchild=rchild=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; tree[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> lev[<span class="number">7</span>]=&#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tree[root].data);</span><br><span class="line">    preorder(tree[root].lchild);</span><br><span class="line">    preorder(tree[root].rchild);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index1=<span class="number">0</span>,index2,root;</span><br><span class="line">    <span class="keyword">bool</span> success=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(index1&lt;<span class="number">7</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==lev[index1])</span><br><span class="line">            &#123;</span><br><span class="line">                index2=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tree[index2].data=lev[index1];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index2<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(tree[i].data!=<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[i].rchild==<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    tree[i].rchild=index2;</span><br><span class="line">                    success=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!success)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=index2+<span class="number">1</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(tree[i].data!=<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(tree[i].lchild==<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tree[i].lchild=index2;</span><br><span class="line">                        success=<span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!success) root=index2;</span><br><span class="line">        index1++;</span><br><span class="line">        success=<span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的总结</title>
    <url>/2019/04/20/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="二叉树的存储结构和基本操作"><a href="#二叉树的存储结构和基本操作" class="headerlink" title="二叉树的存储结构和基本操作"></a>二叉树的存储结构和基本操作</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    node* lchild;</span><br><span class="line">    node* rchild;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建结点</span></span><br><span class="line"><span class="function">node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* Node = <span class="keyword">new</span> node;</span><br><span class="line">    Node-&gt;data = v;</span><br><span class="line">    Node-&gt;lchild=Node-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找并修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(node* root, <span class="keyword">int</span> x, <span class="keyword">int</span> newdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;data==x)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;data = newdata;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    search(root-&gt;lchild,x,newdata);</span><br><span class="line">    search(root-&gt;rchild,x,newdata);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结点的插入, 在根节点为root的树中插入一个数据域为x的结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(node* &amp;root, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root=newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(根据要求，x应该插在左子树)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root-&gt;lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(root-&gt;rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二叉树的创建</span></span><br><span class="line"><span class="function">node* <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node* root=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><br>在insert()函数中，根节点指针root使用了引用&amp;，原因是如果不使用引用，root = newNode(x)这个语句对root的修改就无法作用到原变量上去。而前面的search函数不需要加引用，原因是其修改的是指针root指向的内容，而不是root本身，而对指针指向的结点内容的修改是不需要加引用的。<br><strong>如何判断是否要加引用？</strong><br>如果函数中需要新建结点，即对二叉树的结构作出修改，就需要加引用；<br>如果只是修改当前已有结点的内容，或仅仅是遍历树，就不用加引用。</p>
<h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><h2 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    preorder(root-&gt;lchild);</span><br><span class="line">    preorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    inorder(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">    inorder(root-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    postorder(root-&gt;lchild);</span><br><span class="line">    postorder(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,root-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>无论是先序遍历序列还是后序遍历序列，都必须知道中序遍历序列才能唯一地确定一棵树</strong></p>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node* now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,now-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;lchild != <span class="literal">NULL</span>) q.push(now-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(now-&gt;rchild != <span class="literal">NULL</span>) q.push(now-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>队列中元素是node*型而不是node型，这样可以通过访问地址去修改原元素。</strong><br>如果要求计算每个结点的层次，可在node结构体中增加layer属性。<br>在层次遍历时，root设为1，而后在左右孩子判断非空中，设置左右孩子的层号为当前层号+1.</p>
<h2 id="给定序列，重建二叉树"><a href="#给定序列，重建二叉树" class="headerlink" title="给定序列，重建二叉树"></a>给定序列，重建二叉树</h2><p>给定先序遍历序列和中序遍历序列，重建二叉树.<br>思路：</p>
<ol>
<li>根据先序序列找到根结点，然后在中序序列中确定根结点的位置k。</li>
<li>于是，左子树的结点个数为k-1，因此，左子树的先序序列区间是[2,k]，中序序列区间是[1,k-1]</li>
<li>于是，右子树的先序序列区间是[k+1,n]，中序序列区间是[k+1,n]</li>
<li>往左子树和右子树进行递归构建二叉树。<br>递归过程：</li>
<li>如果递归过程中当前先序序列的区间为[preL,preR]，中序序列的区间为[inL,inR]。</li>
<li>那么左子树的结点个数为numLeft = k-inL，左子树的先序序列区间是[preL+1,preL+numLeft]，中序序列区间是[inL,k-1]</li>
<li>右子树的先序序列区间是[preL+numLeft+1,preR]，中序序列区间是[k+1,inR]<br>递归出口：先序序列的长度小于等于0。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序序列存放于数组pre[]，中序序列存放于数组in[]</span></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> preL, <span class="keyword">int</span> preR, <span class="keyword">int</span> inL, <span class="keyword">int</span> inR)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preL&gt;preR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> node;</span><br><span class="line">    root-&gt;data = pre[preL];</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(k=inL; k&lt;=inR; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[k] == pre[preL])&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numLeft=k-inL;</span><br><span class="line"></span><br><span class="line">    root-&gt;lchild=create(preL+<span class="number">1</span>, preL+numLeft, inL, k<span class="number">-1</span>);</span><br><span class="line">    root-&gt;rchild=create(preL+numLeft+<span class="number">1</span>, preR, k+<span class="number">1</span>, inR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>若给出后序序列和中序序列，只需在根结点的选择上改为post[postR],且左右子树选择的区间进行调整就行。</p>
<h1 id="二叉树的静态实现"><a href="#二叉树的静态实现" class="headerlink" title="二叉树的静态实现"></a>二叉树的静态实现</h1><p><strong>tips：给定一个静态二叉树的数组，判断哪个是根结点的方法是——找那个不是任何结点的子结点的结点，即为根结点</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">int</span> lchild;</span><br><span class="line">    <span class="keyword">int</span> rchild;</span><br><span class="line">&#125;Node[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node[index].data=v;</span><br><span class="line">    Node[index].lchild=Node[index].rchild=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> root,<span class="keyword">int</span> x,<span class="keyword">int</span> newdata)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Node[root].data == x)&#123;</span><br><span class="line">        Node[root].data = newdata;</span><br><span class="line">    &#125;</span><br><span class="line">    search(Node[root].lchild,x,newdata);</span><br><span class="line">    search(Node[root].rchild,x,newdata);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;root,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = newNode(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(由二叉树的性质x应该插在左子树)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(Node[root].lchild,x);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        insert(Node[root].rchild,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Create</span><span class="params">(<span class="keyword">int</span> data[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        insert(root,data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    preorder(Node[root].lchild);</span><br><span class="line">    preorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(Node[root].lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">    inorder(Node[root].rchild);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(Node[root].lchild);</span><br><span class="line">    postorder(Node[root].rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[root].data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LayerOrder</span><span class="params">(<span class="keyword">int</span> root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Node[now].data);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].lchild != <span class="number">-1</span>) q.push(Node[now].lchild);</span><br><span class="line">        <span class="keyword">if</span>(Node[now].rchild != <span class="number">-1</span>) q.push(Node[now].rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS和BFS</title>
    <url>/2019/04/16/DFS%E5%92%8CBFS/</url>
    <content><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>深度优先搜索是一种枚举所有完整路径以遍历所有情况的搜索方法，可以使用栈或递归来实现。<br><strong>递归实现</strong>：递归时系统调用的是系统栈来存放递归中每一层的状态，因此递归实现DFS的本质还是栈。</p>
<h2 id="例子1，0-1背包问题"><a href="#例子1，0-1背包问题" class="headerlink" title="例子1，0/1背包问题"></a>例子1，0/1背包问题</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30</span>;</span><br><span class="line"><span class="keyword">int</span> n,V,maxValue=<span class="number">0</span>; <span class="comment">//物品件数n，背包容量V，最大价值maxValue</span></span><br><span class="line"><span class="keyword">int</span> w[maxn],c[maxn]; <span class="comment">//w[i]为每件物品的重量，c[i]为每件物品的价值</span></span><br><span class="line"><span class="comment">//DFS,index为当前处理的物品编号，sumW和sumC分别为当前总重量和当前总价值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index,<span class="keyword">int</span> sumW,<span class="keyword">int</span> sumC)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//已经完成对n件物品的选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    DFS(index+<span class="number">1</span>,sumW,sumC); <span class="comment">//不选第index件物品</span></span><br><span class="line">    <span class="comment">//只有加入第index件物品后未超过容量V，才能继续</span></span><br><span class="line">    <span class="keyword">if</span>(sumW+w[index] &lt;= V)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sumC+c[index] &gt; maxValue)</span><br><span class="line">        &#123;</span><br><span class="line">            maxValue = sumC+c[index]; <span class="comment">//更新最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">        DFS(index+<span class="number">1</span>,sumW+w[index],sumC+c[index]); <span class="comment">//选第index件物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例子2，枚举序列问题"><a href="#例子2，枚举序列问题" class="headerlink" title="例子2，枚举序列问题"></a>例子2，枚举序列问题</h2><p>枚举从N个整数中选择K个数的所有方案。<br>例如要求：序列A中n个数选k个数使得和为x，最大平方和为maxSumSqu。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n,k,x,maxSumSqu=<span class="number">-1</span>,A[maxn];</span><br><span class="line"><span class="comment">//temp存放临时方案，ans存放平方和最大方案</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp,ans;</span><br><span class="line"><span class="comment">//当前处理index号整数，当前已选整数个数为nowK</span></span><br><span class="line"><span class="comment">//当前已选整数之和为sum，当前已选整数平方和为sumSqu</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> nowK, <span class="keyword">int</span> sum, <span class="keyword">int</span> sumSqu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//找到k个数的和为x</span></span><br><span class="line">    <span class="keyword">if</span>(nowK == k &amp;&amp; sum == x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果比当前找到的更优</span></span><br><span class="line">        <span class="keyword">if</span>(sumSqu &gt; maxSumSqu)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSumSqu = sumSqu;</span><br><span class="line">            ans = temp; <span class="comment">//更新最大平方和，更新最优方案</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//已经处理完n个数，或者超过k个数，或者和超过x，返回</span></span><br><span class="line">    <span class="keyword">if</span>(index == n || nowK &gt; k || sum &gt; x) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//选index号数</span></span><br><span class="line">    temp.push_back(A[index]);</span><br><span class="line">    DFS(index+<span class="number">1</span>,nowK+<span class="number">1</span>,sum+A[index],sumSqu+A[index]*A[index]);</span><br><span class="line">    temp.pop_back(); <span class="comment">//结束分支，使其不会影响不选index号数这条分支</span></span><br><span class="line">    <span class="comment">//不选index号数</span></span><br><span class="line">    DFS(index+<span class="number">1</span>,nowK,sum,sumSqu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另有，如果修改题目为N个整数每个都可以被选择多次，那么只需要修改“选index号数”中的代码为<br><code>DFS(index, nowK+1, sum+A[index], sumSqu+A[index]*A[index])</code></p>
<h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>广度优先搜索一般由队列实现，且总是按层次的顺序进行遍历，基本写法如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(s);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        取出队首元素top;</span><br><span class="line">        访问队首元素top;</span><br><span class="line">        将队首元素出队;</span><br><span class="line">        将top的下一层结点中未曾入队的结点全部入队，并设置为已入队;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="例1，求矩阵中的“块”"><a href="#例1，求矩阵中的“块”" class="headerlink" title="例1，求矩阵中的“块”"></a>例1，求矩阵中的“块”</h2><p>给出一个mxn的矩阵，矩阵中的元素为0或1，称位置(x,y)与其上下左右四个位置(x,y+1)、(x,y-1)、(x-1,y)、(x+1,y)是相邻的，如果矩阵中有若干个1是相邻的，那么称这些1构成了一个“块”，求给定矩阵中“块”的个数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">int</span> m,n;</span><br><span class="line"><span class="keyword">int</span> matrix[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn][maxn]=&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> Y[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=n || x&lt;<span class="number">0</span> || y&gt;=m || y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(matrix[x][y]==<span class="number">0</span> || inq[x][y]==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;node&gt; Q;</span><br><span class="line">    Node.x=x,Node.y=y;</span><br><span class="line">    Q.push(Node);</span><br><span class="line">    inq[x][y]=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node.top=Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> newX=top.x+X[i];</span><br><span class="line">            <span class="keyword">int</span> newY=top.y+Y[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(newX,newY))</span><br><span class="line">            &#123;</span><br><span class="line">                Node.x=newX,Node.y=newY;</span><br><span class="line">                Q.push(Node);</span><br><span class="line">                inq[newX][newY]=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//省略读入01矩阵</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>; <span class="comment">//存放块数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;n;x++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>;y&lt;n;y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[x][y]==<span class="number">1</span> &amp;&amp; inq[x][y]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                BFS(x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出ans</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>为了练习，自己写了个DFS的实现</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> matrix[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> inq[maxn][maxn] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=n || x&lt;<span class="number">0</span> || y&gt;=m || y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(matrix[x][y]==<span class="number">0</span> || inq[x][y]==<span class="literal">true</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> nowX, <span class="keyword">int</span> nowY)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!judge(nowX,nowY))<span class="keyword">return</span>;</span><br><span class="line">    inq[nowX][nowY]=<span class="literal">true</span>;</span><br><span class="line">    DFS(nowX+<span class="number">1</span>,nowY);</span><br><span class="line">    DFS(nowX<span class="number">-1</span>,nowY);</span><br><span class="line">    DFS(nowX,nowY<span class="number">-1</span>);</span><br><span class="line">    DFS(nowX,nowY+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;matrix[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j]==<span class="number">1</span> &amp;&amp; inq[i][j]==<span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                DFS(i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>还可以进行三维数组的BFS处理，除了增加一个z没有什么变化</strong></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构专题（1）</title>
    <url>/2019/04/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="队列部分例题-Mice-and-Rice"><a href="#队列部分例题-Mice-and-Rice" class="headerlink" title="队列部分例题 Mice and Rice"></a>队列部分例题 Mice and Rice</h1><p>代码好像有点问题<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mouse</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">int</span> ran;</span><br><span class="line">&#125;mice[<span class="number">1010</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;mouse&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getGroup</span><span class="params">(<span class="keyword">int</span> np,<span class="keyword">int</span> ng)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> group;</span><br><span class="line">    <span class="keyword">int</span> t=np%ng;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        group=np/ng;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> group=np/ng+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> group;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> np,ng;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;np,&amp;ng);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;np;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;mice[i].weight);</span><br><span class="line">        mice[i].num=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;np;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;temp);</span><br><span class="line">        q.push(mice[temp]);</span><br><span class="line">    &#125;</span><br><span class="line">    mouse tempMouse;</span><br><span class="line">    <span class="keyword">while</span>(q.size()!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;mouse&gt; tempQueue;</span><br><span class="line">        <span class="keyword">int</span> group=getGroup(q.size(),ng);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;group;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> maxWeight=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">int</span> maxNum=<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ng;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                tempMouse=q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(tempMouse.weight&gt;maxWeight)</span><br><span class="line">                &#123;</span><br><span class="line">                    maxWeight=tempMouse.weight;</span><br><span class="line">                    maxNum=tempMouse.num;</span><br><span class="line">                &#125;</span><br><span class="line">                mice[tempMouse.num].ran=group+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempQueue.push(mice[maxNum]);</span><br><span class="line">        &#125;</span><br><span class="line">        q=tempQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    tempMouse=q.front();</span><br><span class="line">    mice[tempMouse.num].ran=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;np<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,mice[i].ran);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mice[np<span class="number">-1</span>].ran);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Sharing"><a href="#Sharing" class="headerlink" title="Sharing"></a>Sharing</h1><p>注意！scanf使用%c格式时是可以读入空格的，因此在输入地址、数据及后继结点地址时，格式不能写成%d%c%d，必须在中间加空格。</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>用STL处理问题</title>
    <url>/2019/04/14/%E7%94%A8STL%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="Course-List-for-Student"><a href="#Course-List-for-Student" class="headerlink" title="Course List for Student"></a>Course List for Student</h1><p>查询学生选课情况的题。<br>第一眼看到后，特别高兴地用包含vector的Student结构，和map&lt;string, Student&gt;处理了，运行结果也正确，然后又特别特别高兴地想着终于能这么快地把题做出来了，乐呵呵地瞥了一眼答案，日，用map会导致超时！！！本题只能使用字符串hash进行求解！！！本题的时间限制是<strong>200ms</strong>，下次再看到这个时间要注意了！！！<br>写都写了，先贴一下超时的写法，当作练手了（暴风哭泣）：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; course;</span><br><span class="line">    Student()</span><br><span class="line">    &#123;</span><br><span class="line">        num=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, Student&gt; li;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">int</span> coursei,ni;</span><br><span class="line">    Student temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;coursei,&amp;ni);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ni;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;name);</span><br><span class="line">            li[name].num++;</span><br><span class="line">            li[name].course.push_back(coursei);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, Student&gt;::iterator it = li.begin();it!=li.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        sort(it-&gt;second.course.begin(),it-&gt;second.course.end());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;name);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d "</span>,name,li[name].num);</span><br><span class="line">        <span class="keyword">int</span> c=li[name].num;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tempv=li[name].course;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;c<span class="number">-1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,tempv[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tempv[c<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行结果如下</span></span><br><span class="line"><span class="number">11</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line">BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1</span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line">ANN0 BOB5 JAY9 LOR6</span><br><span class="line"><span class="number">2</span> <span class="number">7</span></span><br><span class="line">ANN0 BOB5 FRA8 JAY9 JOE4 KAT3 LOR6</span><br><span class="line"><span class="number">3</span> <span class="number">1</span></span><br><span class="line">BOB5</span><br><span class="line"><span class="number">5</span> <span class="number">9</span></span><br><span class="line">AMY7 ANN0 BOB5 DON2 FRA8 JAY9 KAT3 LOR6 ZOE1</span><br><span class="line">ZOE1 ANN0 BOB5 JOE4 JAY9 FRA8 DON2 AMY7 KAT3 LOR6 NON9</span><br><span class="line">ZOE1 <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">ANN0 <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line">BOB5 <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">JOE4 <span class="number">1</span> <span class="number">2</span></span><br><span class="line">JAY9 <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">FRA8 <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">DON2 <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">AMY7 <span class="number">1</span> <span class="number">5</span></span><br><span class="line">KAT3 <span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">LOR6 <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">NON9 <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>然后是用hash处理的不超时代码：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">40010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M=<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>*<span class="number">10</span>+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selectCourse[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getID</span><span class="params">(<span class="keyword">char</span> name[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        id=id*<span class="number">26</span>+(name[i]-<span class="string">'A'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    id=id*<span class="number">10</span>+(name[<span class="number">3</span>]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> coursei,ni;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;coursei,&amp;ni);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;ni;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;name);</span><br><span class="line">            <span class="keyword">int</span> id=getID(name);</span><br><span class="line">            selectCourse[id].push_back(coursei);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;name);</span><br><span class="line">        <span class="keyword">int</span> id=getID(name);</span><br><span class="line">        sort(selectCourse[id].begin(),selectCourse[id].end());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s %d"</span>,name,selectCourse[id].size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;selectCourse[id].size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,selectCourse[id][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的getID()需要重点看看。</p>
<h1 id="string的常见用法详解-Are-They-Equal"><a href="#string的常见用法详解-Are-They-Equal" class="headerlink" title="string的常见用法详解 Are They Equal"></a>string的常见用法详解 Are They Equal</h1><p>题目是按要求比较化为科学计数法后的两个数是否相等。本题考查string的应用，分类讨论。<br>处理方法可先将两个数化成要求的科学计数法形式，然后再进行比较输出结果。</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>大整数运算</title>
    <url>/2019/04/11/%E5%A4%A7%E6%95%B4%E6%95%B0%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h1 id="大整数的存储"><a href="#大整数的存储" class="headerlink" title="大整数的存储"></a>大整数的存储</h1><p>使用数组的形式存储，整数的高位存储在数组的高位，整数的低位存储在数组的低位。并定义一个int型变量len来记录其长度。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    bign()&#123;</span><br><span class="line">        <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>读取时采用字符数组的方式读入，然后反转后用bign数据类型存储。</p>
<h1 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h1><p>将该位上的两个数字与进位相加，得到的结果取个位数作为该位的结果，取十位数作为新的进位。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a, bign b)</span></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len || i&lt;b.len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a.d[i]+b.d[i]+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">        carry = temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.d[c.len++]=carry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h1><p>比较被减位和减位，如果不够减，则令被减位的高位减1、被减位加10再进行减法；如果够减，则直接减。最后一步要注意减法后高位可能有多余的0，要去除它们，但也要保证结果至少有一位数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len || i&lt;b.len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.d[i]&lt;b.d[i])</span><br><span class="line">        &#123;</span><br><span class="line">            a.d[i+<span class="number">1</span>]--;</span><br><span class="line">            a.d[i]+=<span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        c.d[c.len++]=a.d[i]-b.d[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span> &amp;&amp; c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="高精度与低精度的乘法"><a href="#高精度与低精度的乘法" class="headerlink" title="高精度与低精度的乘法"></a>高精度与低精度的乘法</h1><p>取bign的某位与int型整体相乘，再与进位相加，所得结果的个位数作为该位结果，高位部分作为新的进位。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a, bign b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a.d[i]*b+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(carry!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">        carry/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="高精度与低精度的除法"><a href="#高精度与低精度的除法" class="headerlink" title="高精度与低精度的除法"></a>高精度与低精度的除法</h1><p>上一步的余数乘以10加上该步的位，得到该步临时的被除数，将其与除数比较：如果不够除，则该位的商为0；如果够除，则商即为对应的商，余数即为对应的余数。最后一步要注意减法后高位可能有多余的0，要去除它们，但也要保证结果至少有一位数。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">bign <span class="title">divide</span><span class="params">(bign a, bign b,<span class="keyword">int</span>&amp; r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bign c;</span><br><span class="line">    c.len = a.len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line">        <span class="keyword">if</span>(r&lt;b) c.d[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            c.d[i]=r/b;</span><br><span class="line">            r = r%b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c.len<span class="number">-1</span>&gt;=<span class="number">1</span> &amp;&amp; c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">        c.len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>素数判断</title>
    <url>/2019/04/10/%E7%B4%A0%E6%95%B0%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h1 id="判断n是否是素数"><a href="#判断n是否是素数" class="headerlink" title="判断n是否是素数"></a>判断n是否是素数</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> sqr = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sqr;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//即除1和它本身外还包含别的因子</span></span><br><span class="line">        <span class="keyword">if</span>(n%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最大公约数和最小公倍数</title>
    <url>/2019/04/10/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><p>欧几里得算法（辗转相除法）基于如下定理：<br><strong>设a、b均为正整数，则gcd(a,b)=gcd(b,a%b)</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h1><p>当得到a和b的最大公约数d之后，可以马上得到a和b的最小公倍数是ab/d<br><strong>由于ab在实际计算时有可能溢出，因此更恰当的写法是a/d*b，因为d是a和b的最大公约数，所以a/d一定可以整除</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>常用算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数学问题</title>
    <url>/2019/04/10/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="A1049-Counting-Ones"><a href="#A1049-Counting-Ones" class="headerlink" title="A1049.Counting Ones"></a>A1049.Counting Ones</h1><p>这题有意思，在选取测试数据上给自己提个醒，有时间多回顾一下。</p>
<h1 id="Rational-Sum"><a href="#Rational-Sum" class="headerlink" title="Rational Sum"></a>Rational Sum</h1><p>本题要求实现多个分数的加法，并将结果以带分数的形式展示，没找到错在哪。。。先放上来以后再debug吧<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Num</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">&#125;num[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> lcmNum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d/%d"</span>,&amp;num[i].n,&amp;num[i].d);</span><br><span class="line">    &#125;</span><br><span class="line">    Num result=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result.n=result.n*num[i].d+num[i].n*result.d;</span><br><span class="line">        result.d=result.d*num[i].d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> gcdNum=gcd(result.n,result.d);</span><br><span class="line">    result.n/=gcdNum;</span><br><span class="line">    result.d/=gcdNum;</span><br><span class="line">    <span class="keyword">int</span> more=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(result.n&gt;result.d)</span><br><span class="line">    &#123;</span><br><span class="line">        more=result.n/result.d;</span><br><span class="line">        result.n=result.n%result.d;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d/%d"</span>,more,result.n,result.d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,result.n,result.d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Consecutive-Factors"><a href="#Consecutive-Factors" class="headerlink" title="Consecutive Factors"></a>Consecutive Factors</h1><p>策略：由于N不会被除自己以外的大于根号N的整数整除，因此只需要从2~根号N遍历连续整数的第一个，求此时N能被最多多少个连续整数的乘积整除。</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>lower_bound和upper_bound</title>
    <url>/2019/04/04/lower-bound%E5%92%8Cupper-bound/</url>
    <content><![CDATA[<h1 id="应用对象"><a href="#应用对象" class="headerlink" title="应用对象"></a>应用对象</h1><p>用在一个有序数组或容器中。</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ol>
<li>lower_bound(first, last, val)用来寻找在数组或容器的[first, last)范围内第一个值<strong>大于等于</strong>val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</li>
<li>upper_bound(first, last, val)用来寻找在数组或容器的[first, last)范围内第一个值<strong>大于</strong>val的元素的位置，如果是数组，则返回该位置的指针；如果是容器，则返回该位置的迭代器。</li>
<li>如果数组或容器中没有需要寻找的元素，则均返回可以插入该元素的位置的指针或迭代器。</li>
</ol>
]]></content>
      <tags>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>算法初步part2</title>
    <url>/2019/04/02/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5part2/</url>
    <content><![CDATA[<h1 id="To-Fill-or-Not-to-Fill"><a href="#To-Fill-or-Not-to-Fill" class="headerlink" title="To Fill or Not to Fill"></a>To Fill or Not to Fill</h1><p>贪心算法的加油问题，策略如下：<br>从满油状态下能到达的所有加油站中选出下一个前往的加油站：</p>
<ol>
<li>优先前往更低油价的加油站</li>
<li>在没有更低油价的加油站时，前往油价尽可能低的加油站</li>
<li>没有加油站可以到达或到达终点时算法结束</li>
</ol>
<p>代码后续实现后更新。<br>个人实现遇到的问题，在油量的计算上欠缺考虑，导致后半部分花费的计算上遇到困难，答案的做法将终点设置为了数组的第n个位置，简化了计算，代码后续再次尝试后更新。</p>
<h1 id="Insert-or-Merge"><a href="#Insert-or-Merge" class="headerlink" title="Insert or Merge"></a>Insert or Merge</h1><p>先进行插入排序，如果执行过程中发现与给定序列吻合，那么说明是插入排序，计算出下一步的序列后结束算法；<br>如果不是插入排序，那么一定是归并排序，模拟归并排序的过程，如果执行过程中发现与给定序列吻合，那么计算出下一步的序列后结束算法。<br>这样将问题转换为了只需要判断该序列是否是插入排序就行了。</p>
<h1 id="Recover-the-Smallest-Number"><a href="#Recover-the-Smallest-Number" class="headerlink" title="Recover the Smallest Number"></a>Recover the Smallest Number</h1><p>贪心策略：</p>
<ol>
<li>先按字典序排列，然后从前到后进行第二步的处理。</li>
<li>对数字串s1与s2，如果s1+s2&lt;s2+s1,那么把s1放在s2的前面，否则，把s2放在s1的前面。</li>
</ol>
<p>本题想明白了解题方法并利用string来做的话实现难度非常简单，下面代码当作熟悉string的使用：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> s1,<span class="built_in">string</span> s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//string可以一句话实现贪心策略</span></span><br><span class="line">    <span class="keyword">return</span> s1+s2&lt;s2+s1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> numbers[<span class="number">10010</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    sort(numbers,numbers+n,cmp);</span><br><span class="line">    <span class="built_in">string</span> result;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result+=numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(result.size()!=<span class="number">0</span> &amp;&amp; result[<span class="number">0</span>] == <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result.erase(result.begin());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result.size()==<span class="number">0</span>)<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;result;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Radix"><a href="#Radix" class="headerlink" title="Radix"></a>Radix</h1><p>题意为给出两个整数，并给出其中一个数的进制，要求判断另一个数在何种进制下能与其相等。<br>做法为将给出进制的那个数转换成十进制数，然后判断这个十进制数与另一个数的大小，得出另一个数的进制所在的区间。<br>对该区间进行二分查找，进行是否存在相等情况的判断。<br>需要注意的是，进制转换问题，由于有“a”“b”等，所以选择使用字符数组对每个数据进行存储较好；<br>直接暴力枚举遍历会导致超时，变量尽量使用longlong类型，同时存在溢出的可能，需要进行溢出判断。<br>题目看着不难，做起来好麻烦啊。。。。。。暂时先放着吧。。。。。。</p>
<h1 id="Shopping-in-Mars"><a href="#Shopping-in-Mars" class="headerlink" title="Shopping in Mars"></a>Shopping in Mars</h1><p>实质为连续子序列和的问题，可以利用upper_bound来进行处理。</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>map的应用总结</title>
    <url>/2019/04/01/map%E7%9A%84%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>map会以键从小到大的顺序自动排序（同set一样内部用红黑树实现的）</strong><br>可用来处理hashTable数组处理不了的情况。</p>
<h1 id="map的定义及访问"><a href="#map的定义及访问" class="headerlink" title="map的定义及访问"></a>map的定义及访问</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mp1;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; mp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下标访问</span></span><br><span class="line"><span class="keyword">int</span> a = mp1[<span class="string">"test"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;::iterator it=mp.begin(); it!=mp.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d"</span>, it-&gt;first , it-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map会以键从小到大的顺序自动排序。</p>
<h1 id="map的常用函数"><a href="#map的常用函数" class="headerlink" title="map的常用函数"></a>map的常用函数</h1><ol>
<li><p>find(key)，返回键为key的映射的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> iter = m.find(key);</span><br><span class="line"> <span class="keyword">if</span>(iter!=m.end())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> iter-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure>
<p>find()不成功则为m.end()</p>
</li>
<li>erase()<br>1) mp.erase(it)，it为需要删除的元素的迭代器。<br>2) mp.erase(key), key为欲删除的映射的键。<br>3) mp.erase(first, last), first和last为需要删除的区间的起始迭代器和末尾迭代器的下一个地址。</li>
<li>size(), 获得map中映射的对数。</li>
<li>clear(), 用来清空map中的所有元素。</li>
</ol>
]]></content>
      <tags>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>算法初步part1</title>
    <url>/2019/03/30/%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5part1/</url>
    <content><![CDATA[<h1 id="PAT-Judge"><a href="#PAT-Judge" class="headerlink" title="PAT Judge"></a>PAT Judge</h1><p>模拟pat考试的成绩排序问题，难点在于排序的明示要求和隐含规则上，写的代码思路上大致正确，但未考虑到隐含的一个边界情况，<br>同时在程序实现的一些细节上没有考虑到位，导致走了弯路，包括以下几点：</p>
<ol>
<li>结构体的设计上，应该包含哪些元素，自己写的时候没有考虑完全，导致后续代码中出现冗余和思路不够清晰的问题。</li>
<li>结构体的初始化不熟练，数组初始化不熟练，memset等。</li>
</ol>
<p><strong>补充：</strong><br>关于输入00001形式的id号，以int型读入，输出时保证也为00001形式的id号的方法如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> te;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;te);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%05d"</span>,te);</span><br><span class="line"><span class="comment">//即printf的格式输出，05d表示输出五位，不足五位数的前面用零填充</span></span><br></pre></td></tr></table></figure></p>
<p>memset的用法如下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//memset的用法</span></span><br><span class="line"><span class="built_in">memset</span>(stu[i].score, <span class="number">-1</span>, <span class="keyword">sizeof</span>(stu[i].score));</span><br></pre></td></tr></table></figure></p>
<p>代码后续重新实现后再更新。<br><strong>哈哈哈哈，老子的代码来啦~</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> score[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">int</span> total;</span><br><span class="line">    <span class="keyword">int</span> perfect;</span><br><span class="line">    <span class="keyword">int</span> sub;</span><br><span class="line">&#125;stu[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> full[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> N,K,M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        stu[i].id=i;</span><br><span class="line">        <span class="comment">//memset的用法</span></span><br><span class="line">        <span class="built_in">memset</span>(stu[i].score, <span class="number">-1</span>, <span class="keyword">sizeof</span>(stu[i].score));</span><br><span class="line">        stu[i].total=<span class="number">0</span>;</span><br><span class="line">        stu[i].perfect=<span class="number">0</span>;</span><br><span class="line">        stu[i].sub=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(student s1, student s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1.total != s2.total) <span class="keyword">return</span> s1.total&gt;s2.total;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s1.perfect != s2.perfect) <span class="keyword">return</span> s1.perfect&gt;s2.perfect;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> s1.id&lt;s2.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;N, &amp;K, &amp;M);</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;full[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tid,t,ts;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;tid, &amp;t, &amp;ts);</span><br><span class="line">        <span class="keyword">if</span>(stu[tid].score[t]&lt;ts)</span><br><span class="line">        &#123;</span><br><span class="line">            stu[tid].score[t]=ts;</span><br><span class="line">            stu[tid].sub=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(ts == full[t])</span><br><span class="line">                stu[tid].perfect++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(stu[i].sub != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=K;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(stu[i].score[j]!=<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    sum+=stu[i].score[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stu[i].total=sum;</span><br><span class="line">        &#125;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(stu+<span class="number">1</span>,stu+N+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="keyword">int</span> rn=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> before=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(stu[i].sub != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(before != stu[i].total)</span><br><span class="line">            &#123;</span><br><span class="line">                rn++;</span><br><span class="line">                before=stu[i].total;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %05d %d "</span>,rn,stu[i].id,stu[i].total);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=K;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(stu[i].score[j]==<span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"%d"</span>,stu[i].score[j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==K)<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">20</span> <span class="number">30</span> <span class="number">40</span></span><br><span class="line"><span class="number">00001</span> <span class="number">1</span> <span class="number">15</span></span><br><span class="line"><span class="number">00001</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">00002</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">00002</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line"><span class="number">00003</span> <span class="number">1</span> <span class="number">20</span></span><br><span class="line"><span class="number">00003</span> <span class="number">2</span> <span class="number">15</span></span><br><span class="line"><span class="number">00004</span> <span class="number">1</span> <span class="number">-1</span></span><br><span class="line"><span class="number">00004</span> <span class="number">3</span> <span class="number">-1</span></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">1</span> <span class="number">00003</span> <span class="number">35</span> <span class="number">20</span> <span class="number">15</span> -</span><br><span class="line"><span class="number">1</span> <span class="number">00001</span> <span class="number">35</span> <span class="number">15</span> - <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">00002</span> <span class="number">0</span> - <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>总结一下，理清了思路后实现起来并不难，但是在考试时限时进行，最多可能只有一个小时不到的时间去做，需要加强练习才行。</p>
<h1 id="Cars-on-Campus"><a href="#Cars-on-Campus" class="headerlink" title="Cars on Campus"></a>Cars on Campus</h1><p>使用到了map容器，自己第一次做时忽视了对原数据的车牌号也进行排序，使得处理难以进行。在对车牌号也进行分类排序之后，<br>判断有效数据就变得更加简单了，再建立一个存放有效数据的数组保存对应的有效对，后续能够处理得到结果。<br>代码后续重新实现后更新。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">information</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> time;</span><br><span class="line">    <span class="keyword">char</span> status[<span class="number">4</span>];</span><br><span class="line">&#125;info[<span class="number">10010</span>],valid[<span class="number">10010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(information i1,information i2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(i1.id,i2.id) != <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">strcmp</span>(i1.id,i2.id)&lt;<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> i1.time&lt;i2.time;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpByTime</span><span class="params">(information i1,information i2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i1.time&lt;i2.time;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> N,K,h,m,s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;N,&amp;K);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s %d:%d:%d %s"</span>,&amp;info[i].id,&amp;h,&amp;m,&amp;s,&amp;info[i].status);</span><br><span class="line">        info[i].time=h*<span class="number">3600</span>+m*<span class="number">60</span>+s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> times[<span class="number">80010</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d:%d:%d"</span>,&amp;h,&amp;m,&amp;s);</span><br><span class="line">        times[i]=h*<span class="number">3600</span>+m*<span class="number">60</span>+s;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(info,info+N,cmp);</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxTime=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(info[i].id,info[i+<span class="number">1</span>].id)==<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(info[i].status,<span class="string">"in"</span>)==<span class="number">0</span></span><br><span class="line">           &amp;&amp; <span class="built_in">strcmp</span>(info[i+<span class="number">1</span>].status,<span class="string">"out"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            valid[j]=info[i];</span><br><span class="line">            valid[j+<span class="number">1</span>]=info[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(mp.find(info[i].id)!=mp.end())</span><br><span class="line">            &#123;</span><br><span class="line">                mp[info[i].id]=mp[info[i].id]+info[i+<span class="number">1</span>].time-info[i].time;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                mp[info[i].id]=info[i+<span class="number">1</span>].time-info[i].time;</span><br><span class="line">            &#125;</span><br><span class="line">            maxTime=max(mp[info[i].id],maxTime);</span><br><span class="line">            j+=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(valid,valid+j,cmpByTime);</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;K;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(valid[h].time&lt;=times[i] &amp;&amp; h&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(valid[h].status,<span class="string">"out"</span>)==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num--;</span><br><span class="line">            &#125;<span class="keyword">else</span> num++;</span><br><span class="line">            h++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;::iterator it=mp.begin();it!=mp.end();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;second==maxTime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s "</span>,it-&gt;first.c_str());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%02d:%02d:%02d"</span>,maxTime/<span class="number">3600</span>,maxTime%<span class="number">3600</span>/<span class="number">60</span>,maxTime%<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下，细节上的bug有点多，比如map中的字符串用string对应，但在输出时用printf需要将其用.c_str()转换，map中的find查询不到的处理方法，i++和j++的大小计算有误，还有各种判断上面的不注意。感觉这个题难点在于需要用到的结构有点多，处理的数据量种类也有点多，计步上容易出错。</p>
<h1 id="hashTable"><a href="#hashTable" class="headerlink" title="hashTable"></a>hashTable</h1><p>这个类型的题目感觉都挺简单的，主要就是在解题时考虑到是否可以使用hashTable来处理，以及把哪个数据作为hashTable要处理的量。<br>A1048. Find Coins这题有点意思，答案给出了用hashTable解决a+b=m问题的方法，大致为:<br>读取数据i时，令hashTable[i]++，判断a+b=m时，枚举每一个i，找hashTable[m-i]是否存在，有的话即存在i+(m-i)=m，即a+b=m。<br>挺巧妙的方法~</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串处理</title>
    <url>/2019/03/29/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="字符数组的输入输出"><a href="#字符数组的输入输出" class="headerlink" title="字符数组的输入输出"></a>字符数组的输入输出</h1><ol>
<li>scanf和printf</li>
<li>getchar和putchar用来输入和输出单个字符</li>
<li>gets:用来输入一行字符串，识别<code>\n</code>作为输入结束，并将其存放于一维数组中<br>puts:用来输出一行字符串，并紧跟一个换行符。</li>
</ol>
<p><strong>gets可以接收空格，scanf遇到空格、回车和Tab键都会认为输入结束，所以它不能接收空格。</strong></p>
<h1 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a>string.h头文件</h1><ol>
<li>strlen(str)<br>得到字符数组中第一个<code>\0</code>前的字符的个数</li>
<li>strcmp(str1，str2)<br>返回两个字符串大小的比较结果，比较原则是字典序<br>1) str1 &lt; str2，则返回一个负整数<br>2) str1 = str2，则返回一个0<br>3) str1 &gt; str2，则返回一个正整数</li>
<li>strcpy(str1, str2)<br>把str2的字符串复制给str1</li>
</ol>
<h1 id="STL的string"><a href="#STL的string" class="headerlink" title="STL的string"></a>STL的string</h1><ol>
<li>string中内容的访问<br>1) 通过下标访问 str[0]<br>2) 通过迭代器访问 <code>string::iterator it = str.begin();*it;</code></li>
<li>常用函数<br>1) +=<br>2) 比较运算符<br>3) length()/size()<br>4) insert(pos, string)<br>   insert(it, it2, it3): 将串[it2,it3)插在it的位置上，三个参数均为迭代器<br>5) erase(it): it为迭代器<br>   erase(first_it, last_it)：删除[first,last)，参数为迭代器<br>6) clear()<br>7) substr(pos, len)：返回从pos号位开始，长度为len的子串<br>8) find(str2)：返回str2在str中第一次出现的位置，如果不是子串，则返回string::npos<br>   find(str2, pos)：从str的pos号位开始匹配str2，返回值同上<br>9) replace(pos, len, str2)：把str从pos号位开始、长度为len的子串替换为str2<br>   replace(it1, it2, str2)：把[it1,it2)范围的子串替换为str2</li>
</ol>
<h1 id="algorithm下的有关函数"><a href="#algorithm下的有关函数" class="headerlink" title="algorithm下的有关函数"></a>algorithm下的有关函数</h1><ol>
<li>reverse(it1, it2)<br>可以将数组指针在[it1,it2)之间的元素<br>或容器的迭代器在[it1,it2)范围内的元素进行反转<br><code>str.reverse(str.begin(),str.end());</code></li>
</ol>
]]></content>
      <tags>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>入门模拟总结part2</title>
    <url>/2019/03/28/%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F%E6%80%BB%E7%BB%93part2/</url>
    <content><![CDATA[<h1 id="一、Hello-World-for-U"><a href="#一、Hello-World-for-U" class="headerlink" title="一、Hello World for U"></a>一、Hello World for U</h1><p>答案给了两种实现，二维数组方式和直接输出方式，但思路都是用数学方法找到通项公式后进行实现。<br>我用的string，并未推导通项公式，赶脚还行○( ＾皿＾)っHiahiahia…<br>代码就放自己的：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> words;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;words;</span><br><span class="line">    <span class="keyword">int</span> N=words.size();</span><br><span class="line">    <span class="keyword">int</span> n1,n2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n1 = (N+<span class="number">2</span>-i)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;=i &amp;&amp; n1*<span class="number">2</span>+i<span class="number">-2</span> == N)</span><br><span class="line">        &#123;</span><br><span class="line">            n2=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> space = n2<span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n1<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,words[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;space;j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c\n"</span>,words[N-i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n1<span class="number">-1</span>;i&lt;n1+n2<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,words[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="二、找零钱问题（进制换算，借位运算问题）"><a href="#二、找零钱问题（进制换算，借位运算问题）" class="headerlink" title="二、找零钱问题（进制换算，借位运算问题）"></a>二、找零钱问题（进制换算，借位运算问题）</h1><p>题意：17个Sickle兑一个Galleon，29个Knut兑一个Sickle，给定应付的价钱P，和实际付款的钱A，计算找零的钱（付的钱不够则为负数）。<br>先挂我的笨办法，建个Money数据结构，然后写个借位函数，不断if判断借位相减，初始时用比较函数判断两者大小然后添加正负号，他喵的有点麻烦。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Money</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> po;</span><br><span class="line">    <span class="keyword">int</span> g;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的m1一定大于m2</span></span><br><span class="line"><span class="function">Money <span class="title">sub</span><span class="params">(Money m1,Money m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Money result;</span><br><span class="line">    <span class="keyword">if</span>(m1.k&lt;m2.k)</span><br><span class="line">    &#123;</span><br><span class="line">        result.k = m1.k+<span class="number">29</span>-m2.k;</span><br><span class="line">        m1.s-=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(m1.s&lt;m2.s)</span><br><span class="line">        &#123;</span><br><span class="line">            result.s = m1.s+<span class="number">17</span>-m2.s;</span><br><span class="line">            m1.g-=<span class="number">1</span>;</span><br><span class="line">            result.g = m1.g-m2.g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.s = m1.s-m2.s;</span><br><span class="line">            result.g = m1.g-m2.g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.k = m1.k-m2.k;</span><br><span class="line">        <span class="keyword">if</span>(m1.s&lt;m2.s)</span><br><span class="line">        &#123;</span><br><span class="line">            result.s = m1.s+<span class="number">17</span>-m2.s;</span><br><span class="line">            m1.g-=<span class="number">1</span>;</span><br><span class="line">            result.g = m1.g-m2.g;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result.s = m1.s-m2.s;</span><br><span class="line">            result.g = m1.g-m2.g;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(Money m1, Money m2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m1.g&gt;m2.g) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m1.g&lt;m2.g) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m1.s&gt;m2.s)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(m1.s&lt;m2.s)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m1.k&lt;m2.k)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Money m1,m2,result;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d.%d.%d %d.%d.%d"</span>,&amp;m2.g,&amp;m2.s,&amp;m2.k,&amp;m1.g,&amp;m1.s,&amp;m1.k);</span><br><span class="line">    <span class="keyword">if</span>(cmp(m1,m2))</span><br><span class="line">    &#123;</span><br><span class="line">        result=sub(m1,m2);</span><br><span class="line">        result.po=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result=sub(m2,m1);</span><br><span class="line">        result.po=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d.%d.%d"</span>,result.po*result.g,result.s,result.k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看答案的做法，直接将货币全部转换成Knut相减计算得到K，然后转换成原来的格式，认真体会，非常巧妙：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Galleon位为：K/(17*29)</span><br><span class="line">Sickle位为：K%(17*29)/29</span><br><span class="line">Knut位为：K%29</span><br></pre></td></tr></table></figure></p>
<p><strong>总结：进制转换理解不到位，一上来不用脑子直接建结构，结果又慢又繁琐，下次稍微用点脑子想问题。</strong><br>后面一个加强版的题同样如此，题目要求计算A+B，答案的做法却突然抽风和我的一样了，现在贴出我更正后的做法：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,c,d,e,f,K;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d.%d.%d %d.%d.%d"</span>,&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);</span><br><span class="line">    K=a*<span class="number">17</span>*<span class="number">29</span>+b*<span class="number">29</span>+c+d*<span class="number">17</span>*<span class="number">29</span>+e*<span class="number">29</span>+f;</span><br><span class="line">    <span class="keyword">int</span> g,s,k;</span><br><span class="line">    g=K/(<span class="number">17</span>*<span class="number">29</span>);</span><br><span class="line">    s=K%(<span class="number">17</span>*<span class="number">29</span>)/<span class="number">29</span>;</span><br><span class="line">    k=K%<span class="number">29</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d.%d.%d"</span>,g,s,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>入门模拟总结part1</title>
    <url>/2019/03/26/%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F%E6%80%BB%E7%BB%93part1/</url>
    <content><![CDATA[<h1 id="一、A-B和C的大小判断"><a href="#一、A-B和C的大小判断" class="headerlink" title="一、A+B和C的大小判断"></a>一、A+B和C的大小判断</h1><h2 id="T-和-T"><a href="#T-和-T" class="headerlink" title="T--和--T"></a><code>T--</code>和<code>--T</code></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处while循环执行了T次，如果用<code>--T</code>则只循环T-1次</p>
<h2 id="int型的数据范围"><a href="#int型的数据范围" class="headerlink" title="int型的数据范围"></a>int型的数据范围</h2><p>int型的数据范围是[-2^31,2^31-1]，因此在此题中两个int相加就会超过范围，<br>必须使用long long作为变量类型，输入输出格式必须为<code>%lld</code></p>
<h2 id="long-long型的数据范围"><a href="#long-long型的数据范围" class="headerlink" title="long long型的数据范围"></a>long long型的数据范围</h2><p>long long的范围是[-2^63,2^63)，若判断A+B和C的大小问题，则有<br><strong>如果两个正数之和等于负数或是两个负数之和等于正数，那么就是溢出</strong><br>具体为：<br>1) A&gt;0,B&gt;0,A+B&lt;0,因此A+B&gt;C<br>2) A&lt;0,B&lt;0,A+B&gt;0,因此A+B&lt;C</p>
<h1 id="二、一元多项式求导"><a href="#二、一元多项式求导" class="headerlink" title="二、一元多项式求导"></a>二、一元多项式求导</h1><p>代码（练习了vector<typename>::iterator it的使用）<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Element</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> norm;</span><br><span class="line">    <span class="keyword">int</span> ex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Element&gt; elements,newElements;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,e;</span><br><span class="line">    Element temp;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;e) != EOF)&#123;</span><br><span class="line">        temp.norm = n;</span><br><span class="line">        temp.ex = e;</span><br><span class="line">        elements.push_back(temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Element&gt;::iterator it = elements.begin();it!=elements.end();it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((*it).ex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp.norm = (*it).norm*(*it).ex;</span><br><span class="line">            temp.ex = (*it).ex<span class="number">-1</span>;</span><br><span class="line">            newElements.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;Element&gt;::iterator it = newElements.begin();it!=newElements.end();it++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(it+<span class="number">1</span>==newElements.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,(*it).norm,(*it).ex);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d "</span>,(*it).norm,(*it).ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></typename></p>
<p>tips:</p>
<ol>
<li>如果求导之后没有任何非零项，需要输出0 0。<br>这个题目中未说明，上述代码也没有考虑到这点。</li>
<li>scanf手动中止输入的方法：<br>1) <code>scanf(&quot;&quot;) != EOF</code>输入直到文件末尾。<br>2) 在控制台中（Windows）回车后用ctrl+z再回车中止输入。(Linux中为ctrl+d)</li>
</ol>
<h1 id="三、A-B-for-Polynomials"><a href="#三、A-B-for-Polynomials" class="headerlink" title="三、A+B for Polynomials"></a>三、A+B for Polynomials</h1><p>简单做法：<br>定义double型数组p[n]表示幂次为n的项的系数，于是可以在读入两个多项式的时候就进行加法操作在p[n]上，其他细节操作添加上就行了。</p>
<h1 id="四、多项式的乘法运算"><a href="#四、多项式的乘法运算" class="headerlink" title="四、多项式的乘法运算"></a>四、多项式的乘法运算</h1><p>简单做法:<br>先获得第一个多项式的系数，然后在输入第二个多项式的时候把每个系数循环与第一个多项式的系数相乘，指数同样操作，然后累加，输出。<br>同三一样，也只需要用到一个数组，边读入边处理。</p>
<h1 id="五、成绩排名问题"><a href="#五、成绩排名问题" class="headerlink" title="五、成绩排名问题"></a>五、成绩排名问题</h1><p>如果只需要找最大最小值等，可以考虑直接在读取数据时就进行比较筛选，只对最大最小值进行存储，不必另建数组保存全部数据。</p>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>日期处理和进制转换问题</title>
    <url>/2019/03/25/%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86%E5%92%8C%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="日期处理问题"><a href="#日期处理问题" class="headerlink" title="日期处理问题"></a>日期处理问题</h1><p>思路：令日期不断加1天，直到第一个日期等于第二个日期为止，统计得出答案。<br>可用二维数组存放每个月的天数和平年闰年是否。</p>
<h1 id="进制转换问题"><a href="#进制转换问题" class="headerlink" title="进制转换问题"></a>进制转换问题</h1><ol>
<li>将P进制转换成十进制<br>从个位到高位起分别乘P的次方，后加起来即为对应的十进制数。</li>
<li>将十进制转换成P进制<br>不断除以P取余数保存，直到商为0，将所得的余数以最后一次为最高位输出，即为对应的P进制数。</li>
</ol>
]]></content>
      <tags>
        <tag>刷题总结</tag>
      </tags>
  </entry>
  <entry>
    <title>priority_queue的简单应用</title>
    <url>/2019/03/25/priority-queue%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>priority_queue的本质是堆，于是可作为堆来用以解决一些贪心问题，Dijkstra算法优化等。</p>
<h1 id="针对结构体的第一种方式——重载操作符"><a href="#针对结构体的第一种方式——重载操作符" class="headerlink" title="针对结构体的第一种方式——重载操作符"></a>针对结构体的第一种方式——重载操作符</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (pat p1,pat p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注意，与cmp相反，此时产生的队列是得分高的优先级高</span></span><br><span class="line">        <span class="keyword">return</span> p1.score &lt; p2.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pat&gt; q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="针对结构体的第二种方式——cmp"><a href="#针对结构体的第二种方式——cmp" class="headerlink" title="针对结构体的第二种方式——cmp"></a>针对结构体的第二种方式——cmp</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(pat p1, pat p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.score&lt;p2.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    priority_queue&lt;pat, <span class="built_in">vector</span>&lt;pat&gt;, cmp&gt; q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相较而言，第二种方式实现较为复杂。</p>
<h1 id="priority-queue的其他常用操作"><a href="#priority-queue的其他常用操作" class="headerlink" title="priority_queue的其他常用操作"></a>priority_queue的其他常用操作</h1><p><code>push()</code><br><code>top() //使用前注意判断是否为空</code><br><code>pop()</code><br><code>empty()</code><br><code>size()</code><br>两种自带优先级设置<br><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; q //数字大的优先级高</code><br><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q //数字小的优先级高</code></p>
]]></content>
      <tags>
        <tag>C++基础知识</tag>
      </tags>
  </entry>
</search>
